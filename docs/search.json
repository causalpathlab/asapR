[{"path":"/articles/introduction.html","id":"step-1-fast-pseudo-bulk-sampling","dir":"Articles","previous_headings":"","what":"Step 1: Fast pseudo-bulk sampling","title":"1. Introduction: We want cell topic estimation ASAP","text":"can squeeze 5000 cells 31 pseudo-bulk samples. gene-gene correlation structures preserved PB data.","code":".bulk <- asap_random_bulk_mtx(asap.data$mtx,                               asap.data$row,                               asap.data$col,                               asap.data$idx,                               num_factors = 5) Y <- asap_stretch_nn_matrix_columns(.bulk$PB)*100 pheatmap(t(Y))"},{"path":"/articles/introduction.html","id":"step-2-non-negative-matrix-factorization-to-learn-the-definition-of-topics","dir":"Articles","previous_headings":"","what":"Step 2: Non-negative Matrix Factorization to learn the definition of “topics”","title":"1. Introduction: We want cell topic estimation ASAP","text":"convenient routine create structure plot topic proportion matrix.","code":".nmf <- asap_fit_pmf(Y,                      maxK = 5,                      max_iter = 200,                      svd_init = TRUE,                      verbose = FALSE) names(.nmf) ## [1] \"log.likelihood\" \"beta\"           \"log.beta\"       \"log.beta.sd\"    ## [5] \"theta\"          \"log.theta.sd\"   \"log.theta\"      \"row.sum\" pheatmap(t(.nmf$log.beta[gg, ]), Rowv=NA, Colv=NA, scale=\"none\", main=\"logBeta\") plot.struct <- function(.prop){     .order <- order(apply(.prop, 1, which.max))     .melt <- melt(.prop)     .melt$Var1 <- factor(.melt$Var1, .order)      ggplot(.melt, aes(Var1,value,fill=as.factor(Var2))) +         geom_bar(stat=\"identity\") +         scale_fill_brewer(\"Topics\", palette = \"Paired\") +         ylab(\"topic proportions\") } .bulk.topic <- pmf2topic(.nmf$beta, .nmf$theta) plot.struct(.bulk.topic$prop) +     xlab(\"pseudobulk samples\")"},{"path":"/articles/introduction.html","id":"step-3--cell-level-recalibration-to-recover-cell-level-topic-proportions","dir":"Articles","previous_headings":"","what":"Step 3. Cell-level recalibration to recover cell-level topic proportions","title":"1. Introduction: We want cell topic estimation ASAP","text":"Topic correlation statistics already appealing.  can quantify topic proportions based correlation results.","code":".stat <- asap_pmf_regression_mtx(asap.data$mtx,                                  asap.data$row,                                  asap.data$col,                                  asap.data$idx,                                  log_beta = .nmf$log.beta,                                  beta_row_names = .bulk$rownames)  R <- apply(.stat$corr, 2, scale) par(mfrow=c(2,2)) for(k in 1:4){     plot(R[,k], R[,k+1],          col = kk+1, cex=.3,          xlab=paste(\"Std. Cor.\", k),          ylab=paste(\"Std. Cor.\", k + 1)) } .topic <- pmf2topic(.stat$beta, .stat$theta) pheatmap(t(.topic$prop[order(kk),]), Rowv=NA, Colv=NA, cluster_cols = F) pheatmap(t(vv[order(kk),]), Rowv=NA, Colv=NA, cluster_cols = F) plot.struct(.topic$prop) +     theme(axis.text.x = element_blank()) +     theme(axis.ticks.x = element_blank()) +     xlab(paste(nrow(R),\"cells\")) .df <- data.frame(project.proportions(.topic$prop), kk) ggplot(.df, aes(xx,yy)) +     theme_void() +     facet_grid(. ~ kk) +     geom_hex(bins=20) +     scale_fill_distiller(direction=1)"},{"path":"/articles/note_batch_correction_1_concept.html","id":"a-generative-scheme-for-a-single-cell-count-matrix-with-multiplicative-batch-effects","dir":"Articles","previous_headings":"","what":"A generative scheme for a single-cell count matrix with multiplicative batch effects","title":"2. Batch correction within each pseudobulk sample","text":"encounter single-cell expression data consisting multiple batches. One primary goals identify cell types (clusters/factors) cell-type-specific gene expression patterns. However, distinguishing batch-specific cell-type-specific genes factorization method challenging often identifiable data alone. gene gg cell jj, gene expression YgjY_{gj} sampled Poisson distribution rate parameter: λgj=λgj𝗎𝗇𝖻𝗂𝖺𝗌𝖾𝖽×∏kδgkXkj,\\lambda_{gj} = \\lambda_{gj}^{\\textsf{unbiased}} \\times \\prod_{k} \\delta_{gk}^{X_{kj}}, affected batch effects δgk\\delta_{gk}. formally, letting XkjX_{kj} batch membership matrix, assigning cell jj batch kk Xkj=1X_{kj}=1, assume average gene expression rates linearly affected log-transformed space: 𝔼[lnYgj]=ln(∑tβgtθjt)+∑klnδgkXkj.\\mathbb{E}\\!\\left[\\ln Y_{gj}\\right] = \\ln \\left( \\sum_{t} \\beta_{gt} \\theta_{jt} \\right) + \\sum_{k} \\ln\\delta_{gk} X_{kj}. can accurately estimate true batch effect matrix, say δgk\\delta_{gk}, straightforward adjust difference batches. can identify true batch effect δgk\\delta_{gk} genes gg specifically expressed batch kk? match cells ii jj sampled batches aa bb, respectively, expect batch-specific difference δga≠δgk\\delta_{ga} \\neq \\delta_{gk} persist even amplify, difference originated cell types vanish. problem equivalent estimating potential outcome gene expressions batch kk, 𝔼[Ygj(k)]\\mathbb{E}\\!\\left[Y_{gj}^{(k)}\\right].","code":"library(pheatmap) set.seed(1331)  m <- 500 # genes n <- 1000 # cells nb <- 2 # batches  ## 1. batch membership X <- matrix(0, n, nb) batch <- sample(nb, n, replace = TRUE) for(b in 1:nb){     X[batch == b, b] <- 1 }  ## 2. batch effects W.true <- matrix(rnorm(m*nb), m, nb) ln.delta <- apply(W.true %*% t(X), 2, scale)  ## 3. true effects K <- 5 .beta <- matrix(rgamma(m * K, 1), m, K) .theta <- matrix(rgamma(n * K, 1), n, K) lambda.true <- .beta %*% t(.theta) kk <- apply(.theta, 1, which.max)  lambda <- lambda.true * exp(ln.delta) yy <- apply(lambda, 2, function(l) sapply(l, rpois, n=1)) oo <- order(apply(t(.theta), 2, which.max))"},{"path":"/articles/note_batch_correction_1_concept.html","id":"a-causal-inference-approach-to-identify-batch-effects","dir":"Articles","previous_headings":"","what":"A causal inference approach to identify batch effects","title":"2. Batch correction within each pseudobulk sample","text":"dissect batch-specific effect causal inference (potential outcome) framework, assume confounding variables QQ well-distributed across different batches: Overlap: 0<p(Xkj=1|Q)<10 < p(X_{kj}=1|Q) < 1 kk. Moreover, assume covariates sufficient enough induce conditional dependence potential (imputed) gene expression batch assignment mechanisms: Strong ignorability: (Y(k),Y(k′))⊥⊥X|Q(Y(k), Y(k')) \\perp\\!\\!\\!\\perp X | Q k,k′k,k' pairs.","code":""},{"path":"/articles/note_batch_correction_1_concept.html","id":"estimation-of-the-batch-effects-by-matching","dir":"Articles","previous_headings":"","what":"Estimation of the batch effects by matching","title":"2. Batch correction within each pseudobulk sample","text":"Suppose can counterfactually estimate gene expressions certain cell jj cell measured different batches observed batch kk. Zgj=∑(1−Xik)wjiYgi∑(1−Xik)wjiZ_{gj} = \\frac{ \\sum_{} (1 - X_{ik}) w_{ji} Y_{gi} }{ \\sum_{} (1 - X_{ik}) w_{ji} } Like many batch correction methods invented single-cell RNA-seq analysis, assume ZgjZ_{gj} reliably contain biologically-relevant cell state information excluding batch-specific effects cell jj belong. Observed log-likelihood: ∏jp(Ygj|μgs,δgk,Xjk)=∏jPoisson(Ygj|μgs∑kδgkXjk)\\prod_{j} p(Y_{gj}|\\mu_{gs},\\delta_{gk},X_{jk}) =\\prod_{j} \\operatorname{Poisson}(Y_{gj}|\\mu_{gs} \\sum_{k} \\delta_{gk} X_{jk}) Counterfactual log-likelihood: ∏jp(Zgj|μgs,γgs)=∏jPoisson(Zgj|μgsγgs)\\prod_{j} p(Z_{gj}|\\mu_{gs}, \\gamma_{gs}) = \\prod_{j} \\operatorname{Poisson}(Z_{gj}|\\mu_{gs} \\gamma_{gs})","code":""},{"path":"/articles/note_batch_correction_1_concept.html","id":"local-update-maximize-batch-s-specific-parameters","dir":"Articles","previous_headings":"Estimation of the batch effects by matching","what":"Local update: Maximize batch ss-specific parameters","title":"2. Batch correction within each pseudobulk sample","text":"𝔼[μgs]≈∑j∈𝒞sYgj+∑j∈𝒞sZgj∑kδgknsk+nsγgs\\mathbb{E}\\!\\left[\\mu_{gs}\\right] \\approx \\frac{ \\sum_{j \\\\mathcal{C}_{s}} Y_{gj} + \\sum_{j \\\\mathcal{C}_{s}} Z_{gj} } {\\sum_{k} \\delta_{gk} n_{sk} + n_{s} \\gamma_{gs}} Letting psk=nsk/nsp_{sk} = n_{sk} / n_{s}, μgs←Y‾gs+Z‾gs∑kδgkpsk+γgs\\mu_{gs} \\gets \\frac{ \\bar{Y}_{gs} + \\bar{Z}_{gs}} {\\sum_{k} \\delta_{gk} p_{sk} + \\gamma_{gs}} δgk→0\\delta_{gk} \\0 psk=1p_{sk}=1, meaning sample ss just sampled batch kk , μgs→Y‾gs+Z‾gs\\mu_{gs} \\\\bar{Y}_{gs} + \\bar{Z}_{gs} Y‾gs→Y‾gsk=0\\bar{Y}_{gs} \\\\bar{Y}_{gsk} = 0. Therefore, μgs→Z‾gs\\mu_{gs} \\\\bar{Z}_{gs}.","code":""},{"path":"/articles/note_batch_correction_1_concept.html","id":"global-update","dir":"Articles","previous_headings":"Estimation of the batch effects by matching","what":"Global update","title":"2. Batch correction within each pseudobulk sample","text":"𝔼[δgk]≈∑s∑j∈𝒞sXkjYgj∑sμgs∑j∈𝒞sXkj\\mathbb{E}\\!\\left[\\delta_{gk}\\right] \\approx  \\frac{\\sum_{s} \\sum_{j \\\\mathcal{C}_{s}} X_{kj} Y_{gj}}{\\sum_{s} \\mu_{gs} \\sum_{j \\\\mathcal{C}_{s}} X_{kj}} δgk←∑sY‾gsknsk∑sμgsnsk\\delta_{gk} \\gets  \\frac{\\sum_{s} \\bar{Y}_{gsk} n_{sk}} {\\sum_{s} \\mu_{gs} n_{sk}} Y‾gsk→μgs\\bar{Y}_{gsk} \\\\mu_{gs} ss, δgk→1\\delta_{gk} \\1. Y‾gsk<μgs\\bar{Y}_{gsk} < \\mu_{gs} ss, δgk<1\\delta_{gk} < 1. Y‾gsk→0\\bar{Y}_{gsk} \\0 ss, δgk→0\\delta_{gk} \\0.","code":""},{"path":"/articles/note_batch_correction_1_concept.html","id":"algorithm","dir":"Articles","previous_headings":"Estimation of the batch effects by matching","what":"Algorithm","title":"2. Batch correction within each pseudobulk sample","text":"Initialize batch effect δgk←1\\delta_{gk} \\gets 1 gene gg batch kk Initialize γgs←1\\gamma_{gs} \\gets 1 sample ss Static global stat: Sgk←0S_{gk} \\gets 0 pseudo-bulk sample ss cells 𝒞s\\mathcal{C}_{s}, nsk←∑j∈𝒞sXkjn_{sk} \\gets \\sum_{j \\\\mathcal{C}_{s}} X_{kj}, ns←∑knskn_{s} \\gets \\sum_{k} n_{sk}, psk←nsk/nsp_{sk} \\gets n_{sk}/n_{s} Y‾gs←∑j∈𝒞sYgj/ns\\bar{Y}_{gs} \\gets \\sum_{j \\\\mathcal{C}_{s}} Y_{gj} / n_{s} Y‾gsk←∑j∈𝒞sYgjXkj/ns\\bar{Y}_{gsk} \\gets \\sum_{j \\\\mathcal{C}_{s}} Y_{gj} X_{kj} / n_{s} Z‾gs←∑j∈𝒞sZgj/ns\\bar{Z}_{gs} \\gets \\sum_{j \\\\mathcal{C}_{s}} Z_{gj} / n_{s} matching imputation Sgk←Sgk+Y‾gsknskS_{gk} \\gets S_{gk} + \\bar{Y}_{gsk} n_{sk} Iterative-updated global stat: Tgk←0T_{gk} \\gets 0 (Local step) PB sample ss: δ‾gs←∑kδgkpsk\\bar{\\delta}_{gs} \\gets \\sum_{k} \\delta_{gk} p_{sk} μgs←(Y‾gs+Z‾gs)/(γgs+δ‾gs)\\mu_{gs} \\gets (\\bar{Y}_{gs} + \\bar{Z}_{gs}) / (\\gamma_{gs} + \\bar{\\delta}_{gs}) γgs←(Y‾gs)/(μgs)\\gamma_{gs} \\gets (\\bar{Y}_{gs})/(\\mu_{gs}) kk: Tgk←Tgk+μgsnskT_{gk} \\gets T_{gk} + \\mu_{gs} n_{sk} (Global step) batch kk: δgk←Sgk/Tgk\\delta_{gk} \\gets S_{gk} / T_{gk} Repeat previous three steps (5-7) convergence","code":""},{"path":"/articles/note_batch_correction_1_concept.html","id":"a-toy-example","dir":"Articles","previous_headings":"","what":"A toy example","title":"2. Batch correction within each pseudobulk sample","text":"adjust batch membership random projection matrix: [1,] 0.7617260 -0.7617260 [2,] 0.8283630 -0.8283630 [3,] 0.8099248 -0.8099248 [4,] -0.7250199 0.7250199 [5,] 0.6651915 -0.6651915 adjust batch effects: [1,] -2.276319e-16 2.276319e-16 [2,] -5.524025e-16 5.524025e-16 [3,] -2.934286e-16 2.934286e-16 [4,] 3.075415e-16 -3.075415e-16 [5,] -3.636223e-16 3.636223e-16 Can recover original batch effects?  independent cell type effects?  adjusting estimated batch effects, can recover unbiased cell type effects? following adjustment:  , adjusted batch effects:","code":"## 1. project K <- 5 R <- matrix(rnorm(m * K), K, m) Q.raw <- R %*% yy # K x n cor(t(Q.raw), X) [,1]       [,2] ## 2. regress out ## ##  X theta = X inv(X'X) X' Y ##          = U D V' V inv(D^2) V' (U D V')' Y ##          = U inv(D) V' V D U' Y ##          = U U' Y  x.svd <- svd(X) U <- x.svd$u U.t <- t(x.svd$u)  Q.t <- t(Q.raw) Q.t <- Q.t - U %*% U.t %*% Q.t Q <- t(Q.t) cor(Q.t, X) [,1]          [,2] q.svd <- svd(Q)  ## 3. sorting B <- (sign(q.svd$v) + 1)/2 ss <- apply(sweep(B, 2, 2^(seq(0,K-1)), `*`), 1, sum) + 1 feat.dn <- apply(Q, 2, function(x) x / sqrt(sum(x^2))) knn <- 3 d <- nrow(feat.dn)  library(RcppAnnoy) ## a. construct dictionary for each batch dict.list <- lapply(sort(unique(batch)),                     function(b) { new(AnnoyAngular, d) })  for(j in 1:length(batch)){     b <- batch[j]     dict.list[[b]]$addItem(j, feat.dn[,j]) }  for(dd in dict.list){     dd$build(50) }  ## b. a simplified routine to retrieve and estimate counterfactual y .counterfactual <- function(j){     v <- feat.dn[,j]      nn <- c()     dd <- c()      for(k in 1:nb){         if(k == batch[j]) next         .nn <- dict.list[[k]]$getNNsByVector(v, knn)         .dd <- apply(feat.dn[, .nn], 2, function(u) sum((u - v)^2))         nn <- c(nn, .nn)         dd <- c(dd, .dd)     }      w <- exp(-(dd - max(dd)))     w <- w/sum(w)      yy[, nn, drop = FALSE] %*% matrix(w, ncol=1) } ngene <- nrow(yy) nbatch <- ncol(X) nsample <- max(ss)  .delta.db <- matrix(1, ngene, nbatch)       # gene x batch effects .delta.num.db <- matrix(0, ngene, nbatch)    # gene x batch numerators .delta.denom.db <- matrix(0, ngene, nbatch)  # gene x batch denominators  .prob.bs <- matrix(0, nbatch, nsample)      # batch x sample probabilities .size.bs <- matrix(0, nbatch, nsample)      # batch x sample freq .ybar.ds <- matrix(0, ngene, nsample)       # gene x sample observed average .zbar.ds <- matrix(0, ngene, nsample)       # gene x sample imputed average .mu.ds <- matrix(1, ngene, nsample)         # gene x sample adjusted average  ## Precalculate some statistics for(s in 1:nsample){     if(sum(ss == s) < 1) next      .yy <- yy[, ss == s, drop = FALSE]     .zz <- do.call(cbind, lapply(which(ss == s), .counterfactual))      .ybar.ds[,s] <- apply(.yy, 1, mean)     .zbar.ds[,s] <- apply(.zz, 1, mean)     .prob.bs[,s] <- colMeans(X[ss == s, ])     .size.bs[,s] <- colSums(X[ss == s, ])      .y.dsb <- yy[, ss == s, drop = FALSE] %*% X[ss == s, , drop = FALSE]     .delta.num.db <- .delta.num.db + .y.dsb }  .gamma.ds <- matrix(1, ngene, nsample)  for(iter in 1:100){     .mu.ds <- (.ybar.ds + .zbar.ds) / (.delta.db %*% .prob.bs + .gamma.ds + 1e-8)     .gamma.ds <- .zbar.ds / (.mu.ds + 1e-8)     .delta.db <- .delta.num.db / (.mu.ds %*% t(.size.bs) + 1e-8) } par(mfrow=c(1,2)) plot(.delta.db[,1], W.true[,1], pch=19, xlab=\"estimated delta\", ylab=\"true delta effect\", main=\"batch1\") plot(.delta.db[,2], W.true[,2], pch=19, xlab=\"estimated delta\", ylab=\"true delta effect\", main=\"batch2\") y.true <- sweep(lambda.true %*% X, 2, colSums(X), `/`) par(mfrow=c(1,2)) plot(.delta.db[,1], y.true[,1], pch=19, xlab=\"estimated delta\", ylab=\"true y mean\", main=\"batch1\") plot(.delta.db[,2], y.true[,2], pch=19, xlab=\"estimated delta\", ylab=\"true y mean\", main=\"batch2\") ybar <- sweep(yy %*% X, 2, colSums(X), `/`) par(mfrow=c(1,2)) plot(ybar[,1], y.true[,1], pch=19, xlab=\"sample mean\", ylab=\"true y mean\", log=\"x\", main=\"batch1\") plot(ybar[,2], y.true[,2], pch=19, xlab=\"sample mean\", ylab=\"true y mean\", log=\"x\", main=\"batch2\") ybar.adj <- sweep((yy / .delta.db[, batch]) %*% X, 2, colSums(X), `/`) par(mfrow=c(1,2)) plot(ybar.adj[,1], y.true[,1], pch=19, xlab=\"adjusted sample mean\", ylab=\"true y mean\", log=\"x\", main=\"batch1\") plot(ybar.adj[,2], y.true[,2], pch=19, xlab=\"adjusted sample mean\", ylab=\"true y mean\", log=\"x\", main=\"batch2\") par(mfrow=c(1,2)) .tsne <- Rtsne::Rtsne(log(1 + t(yy)), num_threads=4)$Y plot(.tsne[,1], .tsne[,2], col=batch, pch=19, cex=.5, main=\"before batch adj\",      xlab = \"tsne1\", ylab = \"tsne2\") legend(\"topleft\", c(\"batch #1\", \"batch #2\"), col=1:2, pch=19) .tsne <- Rtsne::Rtsne(log(1 + t(yy/.delta.db[,batch])), num_threads=4)$Y plot(.tsne[,1], .tsne[,2], col=batch, pch=19, cex=.5, main=\"after batch adj\",      xlab = \"tsne1\", ylab = \"tsne2\")"},{"path":"/articles/note_batch_correction_2_asap.html","id":"a-generative-scheme-for-a-single-cell-count-matrix-with-multiplicative-batch-effects","dir":"Articles","previous_headings":"","what":"A generative scheme for a single-cell count matrix with multiplicative batch effects","title":"3. Batch correction incorporated in ASAP","text":"gene gg cell jj, gene expression YgjY_{gj} sampled Poisson distribution rate parameter: λgj=λgj𝗎𝗇𝖻𝗂𝖺𝗌𝖾𝖽×∏kδgkXkj,\\lambda_{gj} = \\lambda_{gj}^{\\textsf{unbiased}} \\times \\prod_{k} \\delta_{gk}^{X_{kj}}, affected batch effects δgk\\delta_{gk}. Letting XkjX_{kj} batch membership matrix, assigning cell jj batch kk Xkj=1X_{kj}=1, assume average gene expression rates linearly affected log-transformed space: 𝔼[lnYgj]=ln(∑tβgtθjt)+∑klnδgkXkj.\\mathbb{E}\\!\\left[\\ln Y_{gj}\\right] = \\ln \\left( \\sum_{t} \\beta_{gt} \\theta_{jt} \\right) + \\sum_{k} \\ln\\delta_{gk} X_{kj}. First, can construct pseudo bulk profiles without considering batch labels, hoping Poisson Matrix Factorization (PMF) method pseudo bulk data identify meaningful topic-specific frequency patterns. can explicitly incorporate experimental designs pseudo bulk data construction can deconfound batch effects resulting average matrix.","code":"library(ggplot2) set.seed(1331)  m <- 500 # genes n <- 1000 # cells nb <- 2 # batches  ## 1. batch membership X <- matrix(0, n, nb) batch <- sample(nb, n, replace = TRUE) for(b in 1:nb){     X[batch == b, b] <- 1 }  ## 2. batch effects W.true <- matrix(rnorm(m*nb), m, nb) ln.delta <- apply(W.true %*% t(X), 2, scale)  ## 3. true effects K <- 5 .beta <- matrix(rgamma(m * K, 1), m, K) .theta <- matrix(rgamma(n * K, 1), n, K) lambda.true <- .beta %*% t(.theta) kk <- kmeans(log1p(.theta), 3, nstart=100)$cluster  lambda <- lambda.true * exp(ln.delta) yy <- apply(lambda, 2, function(l) sapply(l, rpois, n=1)) oo <- order(apply(t(.theta), 2, which.max)) library(asapR) y.data <- lapply(1:nb, function(b) yy[, batch == b, drop = F]) y.data <- lapply(y.data, function(y) Matrix::Matrix(y, sparse = T)) pb.out <- asap_random_bulk_cbind(y.data, num_factors = 9, do_batch_adj = F) pmf.out <- asap_fit_pmf(pb.out$PB, maxK=5)  stat0 <- asap_pmf_regression(Matrix::Matrix(yy, sparse=T),                              log_beta = pmf.out$log.beta,                              beta_row_names = pb.out$rownames,                              do_stdize_beta = T, do_stdize_r = T,                              verbose = T) pb.out <- asap_random_bulk_cbind(y.data, num_factors = 9) pmf.out <- asap_fit_pmf(pb.out$PB, maxK=5)  stat1 <- asap_pmf_regression(Matrix::Matrix(yy, sparse=T),                              log_beta = pmf.out$log.beta,                              beta_row_names = pb.out$rownames,                              r_log_delta = pb.out$log.batch.effect,                              do_stdize_beta = T, do_stdize_r = T,                              verbose = T)  stat.b <- asap_pmf_regression(Matrix::Matrix(yy, sparse=T),                               log_beta = pb.out$log.batch.effect,                               beta_row_names = pb.out$rownames,                               do_stdize_beta = T, do_stdize_r = T,                               verbose = T)"},{"path":"/articles/note_batch_correction_2_asap.html","id":"naive-pmf-analysis","dir":"Articles","previous_headings":"","what":"Naive PMF analysis","title":"3. Batch correction incorporated in ASAP","text":"sorted samples true topic patterns, block structures emerge PMF algorithm applied unbiased data. However, apparent block patterns emerge.  Instead, found batch-specific patterns dominate overall PMF results.","code":"topic0 <- pmf2topic(stat0$beta, stat0$theta) plot.struct(topic0$prop, oo) +     ggtitle(\"sorted by true topics\") topic.batch <- pmf2topic(stat.b$beta, stat.b$theta) plot.struct(topic.batch$prop, order(batch)) +     ggtitle(\"sorted by batch labels\") plot.struct(topic0$prop, order(batch)) +     ggtitle(\"sorted by batch labels\")"},{"path":"/articles/note_batch_correction_2_asap.html","id":"after-adjusting-batch-specific-effects","dir":"Articles","previous_headings":"","what":"After adjusting batch-specific effects","title":"3. Batch correction incorporated in ASAP","text":"hand, can recapitulate true topic-specific block structures deconfounded data. clearly demonstrated following PMF results.  Yet, see batch-specific effects.","code":"topic1 <- pmf2topic(stat1$beta, stat1$theta) plot.struct(topic1$prop, oo) +     ggtitle(\"sorted by true topics\") plot.struct(topic1$prop, order(batch)) +     ggtitle(\"sorted by batch labels\")"},{"path":"/articles/note_faster_nmf_approximation.html","id":"regression-1-approximation-from-the-rows-perspective","dir":"Articles","previous_headings":"","what":"Regression 1: Approximation from the rows’ perspective","title":"4. Expedite Poisson-NMF estimation via alternating regression models","text":"want estimate βik\\beta_{ik} given θjk\\theta_{jk}. ∑,jYijln(∑kβikθjk)−∑,j,kβikθjk≥∑,k∑jYijciklnβikθjkcik−∑,j,kβikθjk\\sum_{,j} Y_{ij} \\ln \\left( \\sum_{k} \\beta_{ik} \\theta_{jk} \\right) - \\sum_{,j,k} \\beta_{ik}\\theta_{jk} \\ge \\sum_{,k} \\sum_{j} Y_{ij} c_{ik} \\ln \\frac{\\beta_{ik} \\theta_{jk}}{c_{ik}} - \\sum_{,j,k}\\beta_{ik}\\theta_{jk} Find correlated factor kk (softly). lnϕik=∑jYij𝔼[lnθjk]∑jYij⏟𝖾𝗆𝗉𝗂𝗋𝗂𝖼𝖺𝗅 𝖼𝗈𝗋𝗋𝖾𝗅𝖺𝗍𝗂𝗈𝗇+𝔼[lnβik]⏟𝗆𝖾𝗆𝗈𝗋𝗒+𝖼𝗈𝗇𝗌𝗍.\\ln \\phi_{ik} = \\underbrace{\\frac{\\sum_{j} Y_{ij} \\mathbb{E}\\!\\left[\\ln \\theta_{jk}\\right]}{\\sum_{j} Y_{ij}}}_{\\textsf{empirical correlation}} +  \\underbrace{\\mathbb{E}\\!\\left[\\ln \\beta_{ik}\\right]}_{\\textsf{memory}} + \\textsf{const.} ∑kϕik=1\\sum_{k} \\phi_{ik} = 1, βik∼Gamma(a0+ϕik∑jYij,b0+∑j𝔼[θjk])\\beta_{ik} \\sim \\operatorname{Gamma}\\left( a_{0} + \\phi_{ik} \\sum_{j} Y_{ij}, \\, b_{0} + \\sum_{j} \\mathbb{E}\\!\\left[\\theta_{jk}\\right] \\right) θjk∼Gamma(a0+ρjk∑iϕikYij,b0+∑i𝔼[βik])\\theta_{jk} \\sim \\operatorname{Gamma}\\left( a_0 + \\rho_{jk}  \\sum_{} \\phi_{ik} Y_{ij} ,\\, b_0 + \\sum_{} \\mathbb{E}\\!\\left[\\beta_{ik}\\right] \\right)","code":""},{"path":"/articles/note_faster_nmf_approximation.html","id":"regression-2-approximation-from-the-columns-perspective","dir":"Articles","previous_headings":"","what":"Regression 2: Approximation from the columns’ perspective","title":"4. Expedite Poisson-NMF estimation via alternating regression models","text":"∑,jYijln(∑kβikθjk)−∑,j,kβikθjk≥∑j,k∑iYijzjklnβikθjkzjk−∑,j,kβikθjk\\sum_{,j} Y_{ij} \\ln \\left( \\sum_{k} \\beta_{ik} \\theta_{jk} \\right) - \\sum_{,j,k} \\beta_{ik}\\theta_{jk} \\ge \\sum_{j,k} \\sum_{} Y_{ij} z_{jk} \\ln \\frac{\\beta_{ik} \\theta_{jk}}{z_{jk}} - \\sum_{,j,k} \\beta_{ik} \\theta_{jk} lnρjk=∑iYij𝔼[lnβik]∑iYij⏟𝖾𝗆𝗉𝗂𝗋𝗂𝖼𝖺𝗅 𝖼𝗈𝗋𝗋𝖾𝗅𝖺𝗍𝗂𝗈𝗇+𝔼[lnθjk]⏟𝗆𝖾𝗆𝗈𝗋𝗒+𝖼𝗈𝗇𝗌𝗍.\\ln \\rho_{jk} = \\underbrace{\\frac{\\sum_{} Y_{ij} \\mathbb{E}\\!\\left[\\ln \\beta_{ik}\\right]}{\\sum_{} Y_{ij}}}_{\\textsf{empirical correlation}} + \\underbrace{\\mathbb{E}\\!\\left[\\ln \\theta_{jk}\\right]}_{\\textsf{memory}} + \\textsf{const.} ∑kρjk=1\\sum_{k} \\rho_{jk} = 1, θjk∼Gamma(a0+ρjk∑iYij,b0+∑i𝔼[βik])\\theta_{jk} \\sim \\operatorname{Gamma}\\left( a_{0} + \\rho_{jk} \\sum_{} Y_{ij},\\, b_{0} + \\sum_{} \\mathbb{E}\\!\\left[\\beta_{ik}\\right] \\right) βik∼Gamma(a0+ϕik∑jYijρjk,b0+∑j𝔼[θjk])\\beta_{ik} \\sim  \\operatorname{Gamma}\\left( a_{0} +  \\phi_{ik} \\sum_{j} Y_{ij} \\rho_{jk}, \\, b_{0} + \\sum_{j} \\mathbb{E}\\!\\left[\\theta_{jk}\\right] \\right)","code":""},{"path":"/articles/note_faster_nmf_approximation.html","id":"final-remark","dir":"Articles","previous_headings":"","what":"Final remark","title":"4. Expedite Poisson-NMF estimation via alternating regression models","text":"result, maximize following lower-bound: L≥∑,j,kYijϕikρjklnβikθjkϕikρjk−∑,j,kβikθjk.L \\ge \\sum_{,j,k} Y_{ij} \\phi_{ik} \\rho_{jk} \\ln \\frac{\\beta_{ik} \\theta_{jk}}{\\phi_{ik} \\rho_{jk}} - \\sum_{,j,k} \\beta_{ik} \\theta_{jk}.","code":""},{"path":"/articles/note_faster_nmf_approximation.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"4. Expedite Poisson-NMF estimation via alternating regression models","text":"","code":"library(asapR) library(pheatmap)  set.seed(1331) d <- 500 n <- 5000 .rnorm <- function(d1,d2) matrix(rnorm(d1 * d2), d1, d2)  uu <- pmax(.rnorm(d, 5), 0) vv <- pmax(.rnorm(n, 5), 0) Y <- uu %*% t(vv) + pmax(.rnorm(d, n), 0) system.time(out <- asap_fit_pmf(Y, maxK=7)) ##    user  system elapsed  ## 206.659 327.108  41.356 u.order <- order(apply(uu, 1, which.max)) pheatmap(out$log.beta[u.order, ], Rowv=NA, Colv=NA, cluster_rows = F, cluster_cols = F) v.order <- order(apply(vv, 1, which.max)) pheatmap(out$log.theta[v.order, ], Rowv=NA, Colv=NA, cluster_rows = F, cluster_cols = F)"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Yongjin Park. Author, maintainer. Sishir Subedi. Author.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Park Y, Subedi S (2024). asapR: Annotating Single-cell data matrix Approximate Pseudo-bulk projection R. R package version 0.2.3.","code":"@Manual{,   title = {asapR: Annotating Single-cell data matrix by Approximate Pseudo-bulk projection in R},   author = {Yongjin Park and Sishir Subedi},   year = {2024},   note = {R package version 0.2.3}, }"},{"path":"/index.html","id":"asap-annotating-single-cell-data-matrix-by-approximate-pseudo-bulk-projection-in-r","dir":"","previous_headings":"","what":"Annotating Single-cell data matrix by Approximate Pseudo-bulk projection in R","title":"Annotating Single-cell data matrix by Approximate Pseudo-bulk projection in R","text":"goal ASAP framework: Cell topic annotation reasonably fast enough integrated typical analysis pipeline. whole algorithm accessible users modest computing resources (e.g., low memory footprint). Batch adjustment follow-analysis render intuitive (causal) interpretations.","code":""},{"path":"/reference/asap_bbknn.html","id":null,"dir":"Reference","previous_headings":"","what":"Reconcile multi-batch matrices by batch-balancing KNN — asap_bbknn","title":"Reconcile multi-batch matrices by batch-balancing KNN — asap_bbknn","text":"Reconcile multi-batch matrices batch-balancing KNN","code":""},{"path":"/reference/asap_bbknn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reconcile multi-batch matrices by batch-balancing KNN — asap_bbknn","text":"","code":"asap_bbknn(   data_nk_vec,   row_names_vec,   KNN_PER_BATCH = 3L,   BLOCK_SIZE = 1000L,   NUM_THREADS = 1L,   verbose = TRUE )"},{"path":"/reference/asap_bbknn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reconcile multi-batch matrices by batch-balancing KNN — asap_bbknn","text":"data_nk_vec list sample x factor matrices row_names_vec list sample x 1 names KNN_PER_BATCH (default: 3) BLOCK_SIZE parallel job size (default: 100) NUM_THREADS number parallel threads (default: 1) verbose (default: TRUE)","code":""},{"path":"/reference/asap_bbknn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reconcile multi-batch matrices by batch-balancing KNN — asap_bbknn","text":"list contains: adjusted (N x K) matrix bbknn batch-balanced kNN adjacency matrix batches batch membership knn edges","code":""},{"path":"/reference/asap_build_interacting_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify pairs of columns interacting with one another — asap_build_interacting_columns","title":"Identify pairs of columns interacting with one another — asap_build_interacting_columns","text":"Identify pairs columns interacting one another","code":""},{"path":"/reference/asap_build_interacting_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify pairs of columns interacting with one another — asap_build_interacting_columns","text":"","code":"asap_build_interacting_columns(   y_dn,   z_dm,   log_beta,   beta_row_names,   knn = 10L,   do_stdize_beta = TRUE,   do_log1p = FALSE,   verbose = TRUE,   NUM_THREADS = 1L,   CELL_NORM = 10000,   BLOCK_SIZE = 1000L )"},{"path":"/reference/asap_build_interacting_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify pairs of columns interacting with one another — asap_build_interacting_columns","text":"y_dn sparse data matrix (D x N) z_dm sparse data matrix (D x M) log_beta D x K log dictionary/design matrix beta_row_names row names log_beta (D vector) knn many nearest neighbours want (default: 10) do_stdize_beta use standardized log_beta (Default: TRUE) do_log1p log(1+y) transformation verbose verbosity NUM_THREADS number threads data reading CELL_NORM sample normalization constant (default: 1e4) BLOCK_SIZE disk /O block size (number columns)","code":""},{"path":"/reference/asap_build_interaction_columns_mtx.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify pairs of columns interacting with one another — asap_build_interaction_columns_mtx","title":"Identify pairs of columns interacting with one another — asap_build_interaction_columns_mtx","text":"Identify pairs columns interacting one another","code":""},{"path":"/reference/asap_build_interaction_columns_mtx.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify pairs of columns interacting with one another — asap_build_interaction_columns_mtx","text":"","code":"asap_build_interaction_columns_mtx(   mtx_file,   row_file,   col_file,   idx_file,   log_beta,   beta_row_names,   knn = 10L,   mtx_file_rhs = NULL,   row_file_rhs = NULL,   col_file_rhs = NULL,   idx_file_rhs = NULL,   do_stdize_beta = TRUE,   do_log1p = FALSE,   verbose = TRUE,   NUM_THREADS = 1L,   CELL_NORM = 10000,   BLOCK_SIZE = 1000L,   MAX_ROW_WORD = 2L,   ROW_WORD_SEP = \"_\",   MAX_COL_WORD = 100L,   COL_WORD_SEP = \"@\" )"},{"path":"/reference/asap_build_interaction_columns_mtx.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify pairs of columns interacting with one another — asap_build_interaction_columns_mtx","text":"mtx_file matrix-market-formatted data file (D x N, bgzip) row_file row names file (D x 1) col_file column names file (N x 1) idx_file matrix-market colum index file log_beta D x K log dictionary/design matrix beta_row_names row names log_beta (D vector) knn many nearest neighbours want (default: 10) mtx_file_rhs right-hand-side matrix-market-formatted data file (bgzip) row_file_rhs right-hand-side row names (gene/feature names) col_file_rhs right-hand-side column names (cell/column names) idx_file_rhs right-hand-side matrix-market colum index file do_stdize_beta use standardized log_beta (Default: TRUE) do_log1p log(1+y) transformation verbose verbosity NUM_THREADS number threads data reading CELL_NORM sample normalization constant (default: 1e4) BLOCK_SIZE disk /O block size (number columns) MAX_ROW_WORD maximum words per line row_files[] ROW_WORD_SEP word separation character replace white space MAX_COL_WORD maximum words per line col_files[] COL_WORD_SEP word separation character replace white space","code":""},{"path":"/reference/asap_fit_pmf.html","id":null,"dir":"Reference","previous_headings":"","what":"A quick PMF estimation based on alternating Poisson regressions — asap_fit_pmf","title":"A quick PMF estimation based on alternating Poisson regressions — asap_fit_pmf","text":"quick PMF estimation based alternating Poisson regressions","code":""},{"path":"/reference/asap_fit_pmf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A quick PMF estimation based on alternating Poisson regressions — asap_fit_pmf","text":"","code":"asap_fit_pmf(   Y_,   maxK,   max_iter = 100L,   verbose = TRUE,   a0 = 1,   b0 = 1,   do_log1p = FALSE,   rseed = 1337L,   svd_init = FALSE,   do_degree_correction = FALSE,   normalize_cols = FALSE,   EPS = 1e-08,   jitter = 1,   NUM_THREADS = 0L )"},{"path":"/reference/asap_fit_pmf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A quick PMF estimation based on alternating Poisson regressions — asap_fit_pmf","text":"Y_ non-negative data matrix (gene x sample) maxK maximum number factors max_iter max number optimization steps verbose verbosity a0 gamma(a0, b0) default: a0 = 1 b0 gamma(a0, b0) default: b0 = 1 do_log1p log(1+y) transformation rseed random seed (default: 1337) svd_init initialize SVD (default: FALSE) normalize_cols normalize columns col_norm (default: FALSE) EPS (default: 1e-8) jitter (default: 0.1) min_iter min number optimization steps","code":""},{"path":"/reference/asap_fit_pmf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A quick PMF estimation based on alternating Poisson regressions — asap_fit_pmf","text":"list contains: log.likelihood log-likelihood trace theta loading (sample x factor) log.theta log-loading (sample x factor) log.theta.sd sd(log-loading) (sample x factor) beta dictionary (gene x factor) log.beta log dictionary (gene x factor) log.beta.sd sd(log-dictionary) (gene x factor)","code":""},{"path":"/reference/asap_fit_pmf_cbind.html","id":null,"dir":"Reference","previous_headings":"","what":"A quick PMF estimation based on alternating Poisson regressions while sharing a dictionary/factors matrix — asap_fit_pmf_cbind","title":"A quick PMF estimation based on alternating Poisson regressions while sharing a dictionary/factors matrix — asap_fit_pmf_cbind","text":"quick PMF estimation based alternating Poisson regressions sharing dictionary/factors matrix","code":""},{"path":"/reference/asap_fit_pmf_cbind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A quick PMF estimation based on alternating Poisson regressions while sharing a dictionary/factors matrix — asap_fit_pmf_cbind","text":"","code":"asap_fit_pmf_cbind(   y_dn_vec,   maxK,   max_iter = 100L,   verbose = TRUE,   a0 = 1,   b0 = 1,   do_log1p = FALSE,   rseed = 1337L,   EPS = 1e-08,   jitter = 1,   NUM_THREADS = 0L )"},{"path":"/reference/asap_fit_pmf_cbind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A quick PMF estimation based on alternating Poisson regressions while sharing a dictionary/factors matrix — asap_fit_pmf_cbind","text":"y_dn_vec list non-negative data matrices (gene x sample) maxK maximum number factors max_iter max number optimization steps verbose verbosity a0 gamma(a0, b0) default: a0 = 1 b0 gamma(a0, b0) default: b0 = 1 do_log1p log(1+y) transformation rseed random seed (default: 1337) EPS (default: 1e-8) jitter (default: 1) min_iter min number optimization steps","code":""},{"path":"/reference/asap_fit_pmf_cbind.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A quick PMF estimation based on alternating Poisson regressions while sharing a dictionary/factors matrix — asap_fit_pmf_cbind","text":"list contains: log.likelihood log-likelihood trace beta dictionary (gene x factor) log.beta log-dictionary (gene x factor) log.beta.sd sd(log-dictionary) (gene x factor) theta list loading matrices (sample x factor) log.theta list log loadings (sample x factor) log.theta.sd list standard deviations (sample x factor)","code":""},{"path":"/reference/asap_fit_pmf_delta.html","id":null,"dir":"Reference","previous_headings":"","what":"A quick PMF estimation based on alternating Poisson regressions across multiple matrices with the same dimensionality — asap_fit_pmf_delta","title":"A quick PMF estimation based on alternating Poisson regressions across multiple matrices with the same dimensionality — asap_fit_pmf_delta","text":"quick PMF estimation based alternating Poisson regressions across multiple matrices dimensionality","code":""},{"path":"/reference/asap_fit_pmf_delta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A quick PMF estimation based on alternating Poisson regressions across multiple matrices with the same dimensionality — asap_fit_pmf_delta","text":"","code":"asap_fit_pmf_delta(   y_ref,   y_dn_vec,   maxK,   max_iter = 100L,   verbose = TRUE,   a0 = 1,   b0 = 1,   do_log1p = FALSE,   rseed = 1337L,   svd_init = FALSE,   do_degree_correction = FALSE,   normalize_cols = FALSE,   EPS = 1e-08,   jitter = 1,   NUM_THREADS = 0L )"},{"path":"/reference/asap_fit_pmf_delta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A quick PMF estimation based on alternating Poisson regressions across multiple matrices with the same dimensionality — asap_fit_pmf_delta","text":"y_ref reference data matrix (gene x sample) y_dn_vec list non-negative data matrices (gene x sample) maxK maximum number factors max_iter max number optimization steps verbose verbosity a0 gamma(a0, b0) default: a0 = 1 b0 gamma(a0, b0) default: b0 = 1 do_log1p log(1+y) transformation rseed random seed (default: 1337) svd_init initialize SVD (default: FALSE) normalize_cols normalize columns col_norm (default: FALSE) EPS (default: 1e-8) jitter (default: 1) min_iter min number optimization steps","code":""},{"path":"/reference/asap_fit_pmf_delta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A quick PMF estimation based on alternating Poisson regressions across multiple matrices with the same dimensionality — asap_fit_pmf_delta","text":"list contains: log.likelihood log-likelihood trace theta loading (sample x factor) log.theta log-loading (sample x factor) log.theta.sd sd(log-loading) (sample x factor) beta dictionary (gene x factor) log.beta log dictionary (gene x factor) log.beta.sd sd(log-dictionary) (gene x factor) delta list dictionary matrices (gene x factor) log.delta list log dictionary (gene x factor) log.delta.sd list standard deviations (gene x factor)","code":""},{"path":"/reference/asap_fit_pmf_larch.html","id":null,"dir":"Reference","previous_headings":"","what":"A quick PMF estimation based on alternating Poisson regressions with tree-structured priors — asap_fit_pmf_larch","title":"A quick PMF estimation based on alternating Poisson regressions with tree-structured priors — asap_fit_pmf_larch","text":"quick PMF estimation based alternating Poisson regressions tree-structured priors","code":""},{"path":"/reference/asap_fit_pmf_larch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A quick PMF estimation based on alternating Poisson regressions with tree-structured priors — asap_fit_pmf_larch","text":"","code":"asap_fit_pmf_larch(   Y_,   max_depth,   max_iter = 100L,   verbose = TRUE,   a0 = 1,   b0 = 1,   do_log1p = FALSE,   rseed = 1337L,   svd_init = FALSE,   do_degree_correction = FALSE,   normalize_cols = FALSE,   EPS = 1e-08,   jitter = 1,   NUM_THREADS = 0L )"},{"path":"/reference/asap_fit_pmf_larch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A quick PMF estimation based on alternating Poisson regressions with tree-structured priors — asap_fit_pmf_larch","text":"Y_ non-negative data matrix (gene x sample) max_depth maximum depth perfect binary tree max_iter max number optimization steps verbose verbosity a0 gamma(a0, b0) default: a0 = 1 b0 gamma(a0, b0) default: b0 = 1 do_log1p log(1+y) transformation rseed random seed (default: 1337) svd_init initialize SVD (default: FALSE) normalize_cols normalize columns col_norm (default: FALSE) EPS (default: 1e-8) jitter (default: 1.0)","code":""},{"path":"/reference/asap_fit_pmf_larch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A quick PMF estimation based on alternating Poisson regressions with tree-structured priors — asap_fit_pmf_larch","text":"list contains: log.likelihood log-likelihood trace theta loading (sample x factor) log.theta log-loading (sample x factor) log.theta.sd sd(log-loading) (sample x factor) beta dictionary (gene x factor) log.beta log dictionary (gene x factor) log.beta.sd sd(log-dictionary) (gene x factor)","code":""},{"path":"/reference/asap_fit_pmf_rbind.html","id":null,"dir":"Reference","previous_headings":"","what":"A quick PMF estimation based on alternating Poisson regressions while sharing a factor loading/topic proportion matrix while concatenating the rows of data matrices — asap_fit_pmf_rbind","title":"A quick PMF estimation based on alternating Poisson regressions while sharing a factor loading/topic proportion matrix while concatenating the rows of data matrices — asap_fit_pmf_rbind","text":"Y(t) ~ beta(t) * theta","code":""},{"path":"/reference/asap_fit_pmf_rbind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A quick PMF estimation based on alternating Poisson regressions while sharing a factor loading/topic proportion matrix while concatenating the rows of data matrices — asap_fit_pmf_rbind","text":"","code":"asap_fit_pmf_rbind(   y_dn_vec,   maxK,   max_iter = 100L,   verbose = TRUE,   a0 = 1,   b0 = 1,   do_log1p = FALSE,   rseed = 1337L,   EPS = 1e-08,   jitter = 1,   NUM_THREADS = 0L )"},{"path":"/reference/asap_fit_pmf_rbind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A quick PMF estimation based on alternating Poisson regressions while sharing a factor loading/topic proportion matrix while concatenating the rows of data matrices — asap_fit_pmf_rbind","text":"y_dn_vec list non-negative data matrices (gene x sample) maxK maximum number factors max_iter max number optimization steps verbose verbosity a0 gamma(a0, b0) default: a0 = 1 b0 gamma(a0, b0) default: b0 = 1 do_log1p log(1+y) transformation rseed random seed (default: 1337) EPS (default: 1e-8) jitter (default: 1) min_iter min number optimization steps","code":""},{"path":"/reference/asap_fit_pmf_rbind.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A quick PMF estimation based on alternating Poisson regressions while sharing a factor loading/topic proportion matrix while concatenating the rows of data matrices — asap_fit_pmf_rbind","text":"list contains: log.likelihood log-likelihood trace theta loading (sample x factor) log.theta log-loading (sample x factor) log.theta.sd sd(log-loading) (sample x factor) beta list dictionary matrices (gene x factor) log.beta list log dictionary (gene x factor) log.beta.sd list standard deviations (gene x factor)","code":""},{"path":"/reference/asap_pmf_regression.html","id":null,"dir":"Reference","previous_headings":"","what":"PMF regression — asap_pmf_regression","title":"PMF regression — asap_pmf_regression","text":"PMF regression","code":""},{"path":"/reference/asap_pmf_regression.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PMF regression — asap_pmf_regression","text":"","code":"asap_pmf_regression(   y_dn,   log_beta,   beta_row_names,   r_log_delta = NULL,   do_stdize_beta = TRUE,   do_stdize_r = TRUE,   do_log1p = FALSE,   a0 = 1,   b0 = 1,   max_iter = 10L,   verbose = FALSE,   NUM_THREADS = 0L,   BLOCK_SIZE = 1000L )"},{"path":"/reference/asap_pmf_regression.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PMF regression — asap_pmf_regression","text":"y_dn sparse data matrix (D x N) log_beta D x K log dictionary/design matrix beta_row_names row names log_beta (D vector) r_log_delta D x B log batch effect matrix do_stdize_beta use standardized log_beta (Default: TRUE) do_stdize_r standardize correlation matrix R (default: TRUE) do_log1p log(1+y) transformation a0 gamma(a0, b0) (default: 1) b0 gamma(a0, b0) (default: 1) max_iter maximum iterations (default: 10) verbose verbosity NUM_THREADS number threads data reading BLOCK_SIZE disk /O block size (number columns) MAX_ROW_WORD maximum words per line row_files[] ROW_WORD_SEP word separation character replace white space MAX_COL_WORD maximum words per line col_files[] COL_WORD_SEP word separation character replace white space","code":""},{"path":"/reference/asap_pmf_regression.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"PMF regression — asap_pmf_regression","text":"list contains: beta dictionary matrix (row x factor) delta dictionary matrix batch effects (row x batch) corr empirical correlation (column x factor) theta factor loading (column x factor) log.theta log-scaled factor loading (column x factor) colsum sum column (column x 1) rownames row/feature names colnames column/sample names","code":""},{"path":"/reference/asap_pmf_regression_cbind_mtx.html","id":null,"dir":"Reference","previous_headings":"","what":"PMF statistics to estimate factor loading — asap_pmf_regression_cbind_mtx","title":"PMF statistics to estimate factor loading — asap_pmf_regression_cbind_mtx","text":"PMF statistics estimate factor loading","code":""},{"path":"/reference/asap_pmf_regression_cbind_mtx.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PMF statistics to estimate factor loading — asap_pmf_regression_cbind_mtx","text":"","code":"asap_pmf_regression_cbind_mtx(   mtx_files,   row_files,   col_files,   idx_files,   log_beta,   beta_row_names,   log_delta = NULL,   r_batch_names = NULL,   rename_columns = FALSE,   do_stdize_beta = TRUE,   do_stdize_r = TRUE,   do_log1p = FALSE,   verbose = FALSE,   a0 = 1,   b0 = 1,   max_iter = 10L,   NUM_THREADS = 0L,   BLOCK_SIZE = 1000L,   MAX_ROW_WORD = 2L,   ROW_WORD_SEP = \"_\",   MAX_COL_WORD = 100L,   COL_WORD_SEP = \"@\" )"},{"path":"/reference/asap_pmf_regression_cbind_mtx.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PMF statistics to estimate factor loading — asap_pmf_regression_cbind_mtx","text":"log_beta D x K log dictionary/design matrix beta_row_names row names log_beta (D vector) log_delta D x B log batch effects r_batch_names batch names (optional) rename_columns append batch name end column name (default: FALSE) do_stdize_beta use standardized log_beta (default: TRUE) do_stdize_r standardize correlation matrix R (default: TRUE) do_log1p log(1+y) transformation (default: FALSE) verbose verbosity a0 gamma(a0, b0) (default: 1) b0 gamma(a0, b0) (default: 1) max_iter maximum iterations (default: 10) NUM_THREADS number threads data reading BLOCK_SIZE disk /O block size (number columns) MAX_ROW_WORD maximum words per line row_files[] ROW_WORD_SEP word separation character replace white space MAX_COL_WORD maximum words per line col_files[] COL_WORD_SEP word separation character replace white space mtx_file matrix-market-formatted data file (D x N, bgzip) row_file row names file (D x 1) col_file column names file (N x 1) idx_file matrix-market colum index file","code":""},{"path":"/reference/asap_pmf_regression_cbind_mtx.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"PMF statistics to estimate factor loading — asap_pmf_regression_cbind_mtx","text":"list contains: beta dictionary matrix (row x factor) delta dictionary matrix batch effects (row x batch) corr empirical correlation (column x factor) theta factor loading (column x factor) log.theta log-scaled factor loading (column x factor) colsum column sum (column x 1) rownames row names batch.names batch names (based batch.index colnames column names","code":""},{"path":"/reference/asap_pmf_regression_mtx.html","id":null,"dir":"Reference","previous_headings":"","what":"PMF regression — asap_pmf_regression_mtx","title":"PMF regression — asap_pmf_regression_mtx","text":"PMF regression","code":""},{"path":"/reference/asap_pmf_regression_mtx.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PMF regression — asap_pmf_regression_mtx","text":"","code":"asap_pmf_regression_mtx(   mtx_file,   row_file,   col_file,   idx_file,   log_beta,   beta_row_names,   r_log_delta = NULL,   do_stdize_beta = TRUE,   do_stdize_r = TRUE,   do_log1p = FALSE,   a0 = 1,   b0 = 1,   max_iter = 10L,   verbose = FALSE,   NUM_THREADS = 0L,   BLOCK_SIZE = 1000L,   MAX_ROW_WORD = 2L,   ROW_WORD_SEP = \"_\",   MAX_COL_WORD = 100L,   COL_WORD_SEP = \"@\" )"},{"path":"/reference/asap_pmf_regression_mtx.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PMF regression — asap_pmf_regression_mtx","text":"mtx_file matrix-market-formatted data file (D x N, bgzip) row_file row names file (D x 1) col_file column names file (N x 1) idx_file matrix-market colum index file log_beta D x K log dictionary/design matrix (default: TRUE) beta_row_names row names log_beta (D vector) r_log_delta D x B log batch effect matrix do_stdize_beta use standardized log_beta (Default: FALSE) do_stdize_r standardize correlation matrix R (default: TRUE) do_log1p log(1+y) transformation a0 gamma(a0, b0) (default: 1) b0 gamma(a0, b0) (default: 1) max_iter maximum iterations (default: 10) verbose verbosity NUM_THREADS number threads data reading BLOCK_SIZE disk /O block size (number columns) MAX_ROW_WORD maximum words per line row_files[] ROW_WORD_SEP word separation character replace white space MAX_COL_WORD maximum words per line col_files[] COL_WORD_SEP word separation character replace white space","code":""},{"path":"/reference/asap_pmf_regression_mtx.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"PMF regression — asap_pmf_regression_mtx","text":"list contains: beta dictionary matrix (row x factor) delta dictionary matrix batch effects (row x batch) corr empirical correlation (column x factor) theta factor loading (column x factor) log.theta log-scaled factor loading (column x factor) colsum sum column (column x 1) rownames row/feature names colnames column/sample names","code":""},{"path":"/reference/asap_pmf_stat_interacting_columns_mtx.html","id":null,"dir":"Reference","previous_headings":"","what":"Topic statistics to estimate factor loading — asap_pmf_stat_interacting_columns_mtx","title":"Topic statistics to estimate factor loading — asap_pmf_stat_interacting_columns_mtx","text":"Topic statistics estimate factor loading","code":""},{"path":"/reference/asap_pmf_stat_interacting_columns_mtx.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Topic statistics to estimate factor loading — asap_pmf_stat_interacting_columns_mtx","text":"","code":"asap_pmf_stat_interacting_columns_mtx(   mtx_file,   row_file,   col_file,   idx_file,   log_beta,   beta_row_names,   W_nm_list,   mtx_file2 = NULL,   row_file2 = NULL,   col_file2 = NULL,   idx_file2 = NULL,   A_dd_list = NULL,   do_stdize_beta = TRUE,   do_product = FALSE,   NUM_THREADS = 0L,   CELL_NORM = 10000,   BLOCK_SIZE = 1000L,   MAX_ROW_WORD = 2L,   ROW_WORD_SEP = \"_\",   MAX_COL_WORD = 100L,   COL_WORD_SEP = \"@\",   verbose = FALSE )"},{"path":"/reference/asap_pmf_stat_interacting_columns_mtx.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Topic statistics to estimate factor loading — asap_pmf_stat_interacting_columns_mtx","text":"mtx_file matrix-market-formatted data file (D x N, bgzip) row_file row names file (D x 1) col_file column names file (N x 1) idx_file matrix-market colum index file log_beta D x K log dictionary/design matrix beta_row_names row names log_beta (D vector) W_nm_list list(src.index, tgt.index, weights) columns A_dd_list list(src.index, tgt.index, weights) features do_stdize_beta use standardized log_beta (default: TRUE) do_product yi * yj interaction (default: FALSE) NUM_THREADS number threads data reading CELL_NORM normalization constant per data point BLOCK_SIZE disk /O block size (number columns) MAX_ROW_WORD maximum words per line row_files[] ROW_WORD_SEP word separation character replace white space MAX_COL_WORD maximum words per line col_files[] COL_WORD_SEP word separation character replace white space verbose verbosity","code":""},{"path":"/reference/asap_pmf_stat_interacting_columns_mtx.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Topic statistics to estimate factor loading — asap_pmf_stat_interacting_columns_mtx","text":"list contains: beta dictionary matrix (row x factor) corr empirical correlation (column x factor) colsum sum column (column x 1)","code":""},{"path":"/reference/asap_pmf_stat_rbind.html","id":null,"dir":"Reference","previous_headings":"","what":"Topic statistics to estimate factor loading — asap_pmf_stat_rbind","title":"Topic statistics to estimate factor loading — asap_pmf_stat_rbind","text":"Topic statistics estimate factor loading","code":""},{"path":"/reference/asap_pmf_stat_rbind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Topic statistics to estimate factor loading — asap_pmf_stat_rbind","text":"","code":"asap_pmf_stat_rbind(   mtx_files,   row_files,   col_files,   idx_files,   log_beta_vec,   beta_row_names_vec,   do_stdize_beta = FALSE,   do_log1p = FALSE,   verbose = FALSE,   NUM_THREADS = 1L,   BLOCK_SIZE = 100L,   MAX_ROW_WORD = 2L,   ROW_WORD_SEP = \"_\",   MAX_COL_WORD = 100L,   COL_WORD_SEP = \"@\" )"},{"path":"/reference/asap_pmf_stat_rbind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Topic statistics to estimate factor loading — asap_pmf_stat_rbind","text":"do_stdize_beta use standardized log_beta (default: TRUE) do_log1p log(1+y) transformation (default: FALSE) verbose verbosity NUM_THREADS number threads data reading BLOCK_SIZE disk /O block size (number columns) MAX_ROW_WORD maximum words per line row_files[] ROW_WORD_SEP word separation character replace white space MAX_COL_WORD maximum words per line col_files[] COL_WORD_SEP word separation character replace white space mtx_file matrix-market-formatted data file (D x N, bgzip) row_file row names file (D x 1) col_file column names file (N x 1) idx_file matrix-market colum index file log_x D x K log dictionary/design matrix beta_row_names row names log_x (D vector)","code":""},{"path":"/reference/asap_pmf_stat_rbind.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Topic statistics to estimate factor loading — asap_pmf_stat_rbind","text":"list contains: beta.list list dictionary matrices (row x factor) corr.list list empirical correlation matrices (column x factor) colsum.list list column sum vectors (column x 1)","code":""},{"path":"/reference/asap_random_bulk_cbind.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate approximate pseudo-bulk data by random projections while sharing rows/features across multiple data sets. Horizontal concatenation. — asap_random_bulk_cbind","title":"Generate approximate pseudo-bulk data by random projections while sharing rows/features across multiple data sets. Horizontal concatenation. — asap_random_bulk_cbind","text":"Generate approximate pseudo-bulk data random projections sharing rows/features across multiple data sets. Horizontal concatenation.","code":""},{"path":"/reference/asap_random_bulk_cbind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate approximate pseudo-bulk data by random projections while sharing rows/features across multiple data sets. Horizontal concatenation. — asap_random_bulk_cbind","text":"","code":"asap_random_bulk_cbind(   y_dn_vec,   num_factors,   r_row_names = NULL,   r_batch_names = NULL,   rseed = 42L,   verbose = TRUE,   NUM_THREADS = 0L,   CELL_NORM = 10000,   BLOCK_SIZE = 1000L,   do_batch_adj = TRUE,   do_log1p = FALSE,   do_down_sample = TRUE,   save_aux_data = FALSE,   KNN_CELL = 10L,   CELL_PER_SAMPLE = 100L,   BATCH_ADJ_ITER = 100L,   a0 = 1,   b0 = 1 )"},{"path":"/reference/asap_random_bulk_cbind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate approximate pseudo-bulk data by random projections while sharing rows/features across multiple data sets. Horizontal concatenation. — asap_random_bulk_cbind","text":"y_dn_vec list sparse matrices num_factors desired number random factors rseed random seed verbose verbosity NUM_THREADS number threads data reading CELL_NORM normalization constant per data point BLOCK_SIZE disk /O block size (number columns) do_batch_adj (default: FALSE) do_log1p log(x + 1) transformation (default: FALSE) do_down_sample -sampling (default: TRUE) save_aux_data save auxiliary data (default: FALSE) KNN_CELL k-NN cells per batch different batches (default: 10) CELL_PER_SAMPLE -sampling cell per sample (default: 100) BATCH_ADJ_ITER batch Adjustment steps (default: 100) a0 gamma(a0, b0) (default: 1e-8) b0 gamma(a0, b0) (default: 1) take_union_rows take union rows (default: FALSE) weighted_rand_proj save random projection (default: FALSE) MAX_ROW_WORD maximum words per line row_files[] ROW_WORD_SEP word separation character replace white space MAX_COL_WORD maximum words per line col_files[] COL_WORD_SEP word separation character replace white space","code":""},{"path":"/reference/asap_random_bulk_cbind.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate approximate pseudo-bulk data by random projections while sharing rows/features across multiple data sets. Horizontal concatenation. — asap_random_bulk_cbind","text":"list PB pseudobulk (average) data (feature x sample) sum pseudobulk (sum) data (feature x sample) matched.sum kNN-matched pseudobulk data (feature x sample) sum_db batch-specific sum (feature x batch) size size per sample (sample x 1) prob_bs batch-specific frequency (batch x sample) size_bs batch-specific size (batch x sample) batch.effect batch effect (feature x batch) log.batch.effect log batch effect (feature x batch) batch.names batch names (batch x 1) positions pseudobulk sample positions (cell x 1) rand.dict random dictionary (proj factor x feature) rand.proj random projection results (sample x proj factor) colnames column (cell) names rownames feature (gene) names","code":""},{"path":"/reference/asap_random_bulk_cbind_mtx.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate approximate pseudo-bulk data by random projections while sharing rows/features across multiple data sets. Horizontal concatenation. — asap_random_bulk_cbind_mtx","title":"Generate approximate pseudo-bulk data by random projections while sharing rows/features across multiple data sets. Horizontal concatenation. — asap_random_bulk_cbind_mtx","text":"Generate approximate pseudo-bulk data random projections sharing rows/features across multiple data sets. Horizontal concatenation.","code":""},{"path":"/reference/asap_random_bulk_cbind_mtx.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate approximate pseudo-bulk data by random projections while sharing rows/features across multiple data sets. Horizontal concatenation. — asap_random_bulk_cbind_mtx","text":"","code":"asap_random_bulk_cbind_mtx(   mtx_files,   row_files,   col_files,   idx_files,   num_factors,   r_batch_names = NULL,   rows_restrict = NULL,   rename_columns = TRUE,   take_union_rows = FALSE,   rseed = 42L,   verbose = TRUE,   NUM_THREADS = 0L,   CELL_NORM = 10000,   BLOCK_SIZE = 1000L,   do_batch_adj = TRUE,   do_log1p = FALSE,   do_down_sample = TRUE,   save_aux_data = FALSE,   KNN_CELL = 10L,   CELL_PER_SAMPLE = 100L,   BATCH_ADJ_ITER = 100L,   a0 = 1,   b0 = 1,   MAX_ROW_WORD = 2L,   ROW_WORD_SEP = \"_\",   MAX_COL_WORD = 100L,   COL_WORD_SEP = \"@\" )"},{"path":"/reference/asap_random_bulk_cbind_mtx.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate approximate pseudo-bulk data by random projections while sharing rows/features across multiple data sets. Horizontal concatenation. — asap_random_bulk_cbind_mtx","text":"mtx_files matrix-market-formatted data files (bgzip) row_files row names (gene/feature names) col_files column names (cell/column names) idx_files matrix-market colum index files num_factors desired number random factors take_union_rows take union rows (default: FALSE) rseed random seed verbose verbosity NUM_THREADS number threads data reading CELL_NORM normalization constant per data point BLOCK_SIZE disk /O block size (number columns) do_batch_adj (default: FALSE) do_log1p log(x + 1) transformation (default: FALSE) do_down_sample -sampling (default: TRUE) save_aux_data save random projection (default: FALSE) KNN_CELL k-NN cells per batch different batches (default: 10) CELL_PER_SAMPLE -sampling cell per sample (default: 100) BATCH_ADJ_ITER batch Adjustment steps (default: 100) a0 gamma(a0, b0) (default: 1e-8) b0 gamma(a0, b0) (default: 1) MAX_ROW_WORD maximum words per line row_files[] ROW_WORD_SEP word separation character replace white space MAX_COL_WORD maximum words per line col_files[] COL_WORD_SEP word separation character replace white space","code":""},{"path":"/reference/asap_random_bulk_cbind_mtx.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate approximate pseudo-bulk data by random projections while sharing rows/features across multiple data sets. Horizontal concatenation. — asap_random_bulk_cbind_mtx","text":"list PB pseudobulk (average) data (feature x sample) sum pseudobulk (sum) data (feature x sample) matched.sum kNN-matched pseudobulk data (feature x sample) sum_db batch-specific sum (feature x batch) size size per sample (sample x 1) prob_bs batch-specific frequency (batch x sample) size_bs batch-specific size (batch x sample) batch.effect batch effect (feature x batch) log.batch.effect log batch effect (feature x batch) batch.names batch names (batch x 1) positions pseudobulk sample positions (cell x 1) rand.dict random dictionary (proj factor x feature) rand.proj random projection results (sample x proj factor) colnames column (cell) names rownames feature (gene) names","code":""},{"path":"/reference/asap_random_bulk_interacting_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate approximate pseudo-bulk interaction data by random projections — asap_random_bulk_interacting_columns","title":"Generate approximate pseudo-bulk interaction data by random projections — asap_random_bulk_interacting_columns","text":"Generate approximate pseudo-bulk interaction data random projections","code":""},{"path":"/reference/asap_random_bulk_interacting_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate approximate pseudo-bulk interaction data by random projections — asap_random_bulk_interacting_columns","text":"","code":"asap_random_bulk_interacting_columns(   mtx_file,   row_file,   col_file,   idx_file,   num_factors,   W_nm_list,   mtx_file_rhs = NULL,   row_file_rhs = NULL,   col_file_rhs = NULL,   idx_file_rhs = NULL,   A_dd_list = NULL,   rseed = 42L,   do_product = FALSE,   do_log1p = FALSE,   do_down_sample = FALSE,   save_rand_proj = FALSE,   weighted_rand_proj = FALSE,   NUM_THREADS = 0L,   CELL_NORM = 10000,   BLOCK_SIZE = 1000L,   EDGE_PER_SAMPLE = 100L,   a0 = 1,   b0 = 1,   MAX_ROW_WORD = 2L,   ROW_WORD_SEP = \"_\",   MAX_COL_WORD = 100L,   COL_WORD_SEP = \"@\",   verbose = FALSE )"},{"path":"/reference/asap_random_bulk_interacting_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate approximate pseudo-bulk interaction data by random projections — asap_random_bulk_interacting_columns","text":"mtx_file matrix-market-formatted data file (bgzip) row_file row names (gene/feature names) col_file column names (cell/column names) idx_file matrix-market colum index file num_factors desired number random factors W_nm_list list(src.index, tgt.index, weights) columns mtx_file_rhs right-hand-side matrix-market-formatted data file (bgzip) row_file_rhs right-hand-side row names (gene/feature names) col_file_rhs right-hand-side column names (cell/column names) idx_file_rhs right-hand-side matrix-market colum index file A_dd_list list(src.index, tgt.index, weights) features rseed random seed do_product yi * yj interaction (default: FALSE) do_log1p log(x + 1) transformation (default: FALSE) do_down_sample -sampling (default: FALSE) save_rand_proj save random projection (default: FALSE) weighted_rand_proj save random projection (default: FALSE) NUM_THREADS number threads data reading CELL_NORM normalization constant per data point BLOCK_SIZE disk /O block size (number columns) EDGE_PER_SAMPLE -sampling cell per sample (default: 100) a0 gamma(a0, b0) (default: 1) b0 gamma(a0, b0) (default: 1) MAX_ROW_WORD maximum words per line row_file ROW_WORD_SEP word separation character replace white space MAX_COL_WORD maximum words per line col_file COL_WORD_SEP word separation character replace white space verbose verbosity","code":""},{"path":"/reference/asap_random_bulk_interacting_columns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate approximate pseudo-bulk interaction data by random projections — asap_random_bulk_interacting_columns","text":"list PB pseudobulk (average) data (feature x sample) sum pseudobulk (sum) data (feature x sample) size size per sample (sample x 1) positions pseudobulk sample positions (cell pair x 1) rand.dict random dictionary (proj factor x feature) rand.proj random projection results (sample x proj factor) colnames column (cell) names rownames feature (gene) names","code":""},{"path":"/reference/asap_random_bulk_linking_mtx.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate approximate pseudo-bulk data by random projections while linking features across multiple mtx files — asap_random_bulk_linking_mtx","title":"Generate approximate pseudo-bulk data by random projections while linking features across multiple mtx files — asap_random_bulk_linking_mtx","text":"Generate approximate pseudo-bulk data random projections linking features across multiple mtx files","code":""},{"path":"/reference/asap_random_bulk_linking_mtx.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate approximate pseudo-bulk data by random projections while linking features across multiple mtx files — asap_random_bulk_linking_mtx","text":"","code":"asap_random_bulk_linking_mtx(   mtx_files,   row_files,   col_files,   idx_files,   num_factors,   rseed = 42L,   verbose = TRUE,   NUM_THREADS = 1L,   CELL_NORM = 10000,   BLOCK_SIZE = 1000L,   do_log1p = FALSE,   do_down_sample = FALSE,   save_rand_proj = FALSE,   weighted_rand_proj = FALSE,   CELL_PER_SAMPLE = 100L,   a0 = 1e-08,   b0 = 1,   MAX_ROW_WORD = 2L,   ROW_WORD_SEP = \"_\",   MAX_COL_WORD = 100L,   COL_WORD_SEP = \"@\" )"},{"path":"/reference/asap_random_bulk_linking_mtx.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate approximate pseudo-bulk data by random projections while linking features across multiple mtx files — asap_random_bulk_linking_mtx","text":"mtx_files matrix-market-formatted data files (bgzip) row_files row names (gene/feature names) col_files column names (cell/column names) idx_files matrix-market colum index files num_factors desired number random factors per data set rseed random seed verbose verbosity NUM_THREADS number threads data reading CELL_NORM normalization constant per data point BLOCK_SIZE disk /O block size (number columns) do_log1p log(x + 1) transformation (default: FALSE) do_down_sample -sampling (default: FALSE) save_rand_proj save random projection (default: FALSE) weighted_rand_proj save random projection (default: FALSE) CELL_PER_SAMPLE -sampling cell per sample (default: 100) a0 gamma(a0, b0) (default: 1e-8) b0 gamma(a0, b0) (default: 1) MAX_ROW_WORD maximum words per line row_files[] ROW_WORD_SEP word separation character replace white space MAX_COL_WORD maximum words per line col_files[] COL_WORD_SEP word separation character replace white space","code":""},{"path":"/reference/asap_random_bulk_linking_mtx.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate approximate pseudo-bulk data by random projections while linking features across multiple mtx files — asap_random_bulk_linking_mtx","text":"list PB.list pseudobulk (average) data (feature x sample) type sum.list pseudobulk (sum) data (feature x sample) type size.list size per sample (sample x 1) type rownames.list feature (gene) names type colnames column (cell) names across data types positions pseudobulk sample positions (cell x 1) rand.proj random projection results (sample x proj factor) colnames column (cell) names","code":""},{"path":"/reference/asap_random_bulk_mtx.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate approximate pseudo-bulk data by random projections — asap_random_bulk_mtx","title":"Generate approximate pseudo-bulk data by random projections — asap_random_bulk_mtx","text":"Generate approximate pseudo-bulk data random projections","code":""},{"path":"/reference/asap_random_bulk_mtx.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate approximate pseudo-bulk data by random projections — asap_random_bulk_mtx","text":"","code":"asap_random_bulk_mtx(   mtx_file,   row_file,   col_file,   idx_file,   num_factors,   r_covar_n = NULL,   r_covar_d = NULL,   rows_restrict = NULL,   rseed = 42L,   verbose = FALSE,   NUM_THREADS = 0L,   CELL_NORM = 10000,   BLOCK_SIZE = 1000L,   do_log1p = FALSE,   do_down_sample = FALSE,   save_aux_data = FALSE,   weighted_rand_proj = FALSE,   CELL_PER_SAMPLE = 100L,   a0 = 1e-08,   b0 = 1,   MAX_ROW_WORD = 2L,   ROW_WORD_SEP = \"_\",   MAX_COL_WORD = 100L,   COL_WORD_SEP = \"@\" )"},{"path":"/reference/asap_random_bulk_mtx.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate approximate pseudo-bulk data by random projections — asap_random_bulk_mtx","text":"mtx_file matrix-market-formatted data file (bgzip) row_file row names (gene/feature names) col_file column names (cell/column names) idx_file matrix-market colum index file num_factors desired number random factors r_covar_n N x r covariates (default: NULL) r_covar_d D x r covariates (default: NULL) rseed random seed verbose verbosity NUM_THREADS number threads data reading CELL_NORM sample normalization constant (default: 1e4) BLOCK_SIZE disk /O block size (number columns) do_log1p log(x + 1) transformation (default: FALSE) do_down_sample -sampling (default: FALSE) save_aux_data save auxiliary data (default: FALSE) weighted_rand_proj save random projection (default: FALSE) CELL_PER_SAMPLE -sampling cell per sample (default: 100) a0 gamma(a0, b0) (default: 1e-8) b0 gamma(a0, b0) (default: 1) MAX_ROW_WORD maximum words per line row_file ROW_WORD_SEP word separation character replace white space MAX_COL_WORD maximum words per line col_file COL_WORD_SEP word separation character replace white space","code":""},{"path":"/reference/asap_random_bulk_mtx.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate approximate pseudo-bulk data by random projections — asap_random_bulk_mtx","text":"list PB pseudobulk (average) data (feature x sample) sum pseudobulk (sum) data (feature x sample) size size per sample (sample x 1) positions pseudobulk sample positions (cell x 1) rand.dict random dictionary (proj factor x feature) rand.proj random projection results (sample x proj factor) colnames column (cell) names rownames feature (gene) names","code":""},{"path":"/reference/asap_random_bulk_rbind_mtx.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate approximate pseudo-bulk data by random projections while sharing columns/cells across multiple data sets. Vertical concatenation. — asap_random_bulk_rbind_mtx","title":"Generate approximate pseudo-bulk data by random projections while sharing columns/cells across multiple data sets. Vertical concatenation. — asap_random_bulk_rbind_mtx","text":"Generate approximate pseudo-bulk data random projections sharing columns/cells across multiple data sets. Vertical concatenation.","code":""},{"path":"/reference/asap_random_bulk_rbind_mtx.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate approximate pseudo-bulk data by random projections while sharing columns/cells across multiple data sets. Vertical concatenation. — asap_random_bulk_rbind_mtx","text":"","code":"asap_random_bulk_rbind_mtx(   mtx_files,   row_files,   col_files,   idx_files,   num_factors,   rseed = 42L,   verbose = TRUE,   NUM_THREADS = 1L,   CELL_NORM = 10000,   BLOCK_SIZE = 1000L,   do_log1p = FALSE,   do_down_sample = FALSE,   save_rand_proj = FALSE,   weighted_rand_proj = FALSE,   CELL_PER_SAMPLE = 100L,   a0 = 1e-08,   b0 = 1,   MAX_ROW_WORD = 2L,   ROW_WORD_SEP = \"_\",   MAX_COL_WORD = 100L,   COL_WORD_SEP = \"@\" )"},{"path":"/reference/asap_random_bulk_rbind_mtx.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate approximate pseudo-bulk data by random projections while sharing columns/cells across multiple data sets. Vertical concatenation. — asap_random_bulk_rbind_mtx","text":"mtx_files matrix-market-formatted data files (bgzip) row_files row names (gene/feature names) col_files column names (cell/column names) idx_files matrix-market colum index files num_factors desired number random factors per data set rseed random seed verbose verbosity NUM_THREADS number threads data reading CELL_NORM normalization constant per data point BLOCK_SIZE disk /O block size (number columns) do_log1p log(x + 1) transformation (default: FALSE) do_down_sample -sampling (default: FALSE) save_rand_proj save random projection (default: FALSE) weighted_rand_proj save random projection (default: FALSE) CELL_PER_SAMPLE -sampling cell per sample (default: 100) a0 gamma(a0, b0) (default: 1e-8) b0 gamma(a0, b0) (default: 1) MAX_ROW_WORD maximum words per line row_files[] ROW_WORD_SEP word separation character replace white space MAX_COL_WORD maximum words per line col_files[] COL_WORD_SEP word separation character replace white space","code":""},{"path":"/reference/asap_random_bulk_rbind_mtx.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate approximate pseudo-bulk data by random projections while sharing columns/cells across multiple data sets. Vertical concatenation. — asap_random_bulk_rbind_mtx","text":"list PB.list pseudobulk (average) data (feature x sample) type sum.list pseudobulk (sum) data (feature x sample) type size.list size per sample (sample x 1) type rownames.list feature (gene) names type colnames column (cell) names across data types positions pseudobulk sample positions (cell x 1) rand.proj random projection results (sample x proj factor) colnames column (cell) names","code":""},{"path":"/reference/asap_stretch_nn_matrix_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Stretch non-negative matrix — asap_stretch_nn_matrix_columns","title":"Stretch non-negative matrix — asap_stretch_nn_matrix_columns","text":"Stretch non-negative matrix","code":""},{"path":"/reference/asap_stretch_nn_matrix_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stretch non-negative matrix — asap_stretch_nn_matrix_columns","text":"","code":"asap_stretch_nn_matrix_columns(   Y,   qq_min = 0.01,   qq_max = 0.99,   std_min = -8,   std_max = 8,   verbose = TRUE )"},{"path":"/reference/asap_stretch_nn_matrix_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stretch non-negative matrix — asap_stretch_nn_matrix_columns","text":"Y non-negative data matrix(gene x sample) qq_min min quantile (default: 0.01) qq_max min quantile (default: 0.99) std_min min standardization log (default: -8) std_max max standardization log (default: 8) verbose speak (default: TRUE)","code":""},{"path":"/reference/asap_topic_pmf.html","id":null,"dir":"Reference","previous_headings":"","what":"Calibrate topic proportions based on sufficient statistics — asap_topic_pmf","title":"Calibrate topic proportions based on sufficient statistics — asap_topic_pmf","text":"Calibrate topic proportions based sufficient statistics","code":""},{"path":"/reference/asap_topic_pmf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calibrate topic proportions based on sufficient statistics — asap_topic_pmf","text":"","code":"asap_topic_pmf(   beta_dk,   R_nk,   Ysum_n,   a0 = 1,   b0 = 1,   max_iter = 10L,   NUM_THREADS = 0L,   do_stdize_r = TRUE,   verbose = TRUE )"},{"path":"/reference/asap_topic_pmf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calibrate topic proportions based on sufficient statistics — asap_topic_pmf","text":"beta_dk dictionary matrix (feature D  x factor K) R_nk correlation matrix (sample N x factor K) Ysum_n sum vector (sample N x 1) a0 gamma(a0, b0) (default: 1) b0 gamma(a0, b0) (default: 1) max_iter maximum iterations (default: 10) NUM_THREADS number parallel threads (default: 1) do_stdize_r standardize correlation matrix R (default: FALSE) verbose (default: TRUE)","code":""},{"path":"/reference/asap_topic_pmf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calibrate topic proportions based on sufficient statistics — asap_topic_pmf","text":"list contains: beta (D x K) matrix theta (N x K) matrix log.theta (N x K) log matrix log.theta.sd (N x K) standard deviation matrix","code":""},{"path":"/reference/asap_topic_pmf_rbind.html","id":null,"dir":"Reference","previous_headings":"","what":"Calibrate topic proportions based on sufficient statistics — asap_topic_pmf_rbind","title":"Calibrate topic proportions based on sufficient statistics — asap_topic_pmf_rbind","text":"Calibrate topic proportions based sufficient statistics","code":""},{"path":"/reference/asap_topic_pmf_rbind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calibrate topic proportions based on sufficient statistics — asap_topic_pmf_rbind","text":"","code":"asap_topic_pmf_rbind(   beta_dk_list,   R_nk_list,   Y_n_list,   a0 = 1,   b0 = 1,   max_iter = 10L,   NUM_THREADS = 1L,   stdize_r = TRUE,   verbose = TRUE )"},{"path":"/reference/asap_topic_pmf_rbind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calibrate topic proportions based on sufficient statistics — asap_topic_pmf_rbind","text":"beta_dk_list list dictionary matrices (feature D  x factor K) R_nk_list list correlation matrices (sample N x factor K) Y_n_list list sum vectors (sample N x 1) a0 gamma(a0, b0) (default: 1) b0 gamma(a0, b0) (default: 1) max_iter maximum iterations (default: 10) NUM_THREADS number parallel threads (default: 1) stdize_r standardize correlation matrix R (default: TRUE) verbose (default: TRUE)","code":""},{"path":"/reference/asap_topic_pmf_rbind.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calibrate topic proportions based on sufficient statistics — asap_topic_pmf_rbind","text":"list contains: theta (N x K) matrix log.theta (N x K) log matrix log.theta.sd (N x K) standard deviation matrix","code":""},{"path":"/reference/collapse_network.html","id":null,"dir":"Reference","previous_headings":"","what":"Collapse N x N adjacency network into S x S — collapse_network","title":"Collapse N x N adjacency network into S x S — collapse_network","text":"Collapse N x N adjacency network S x S","code":""},{"path":"/reference/collapse_network.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Collapse N x N adjacency network into S x S — collapse_network","text":"","code":"collapse_network(W_nn_list, r_positions, N, S, verbose = TRUE)"},{"path":"/reference/collapse_network.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Collapse N x N adjacency network into S x S — collapse_network","text":"W_nn_list adjacency list r_positions collapsing positions N number vertices S number meta-vertices verbose verbosity","code":""},{"path":"/reference/collapse_network.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Collapse N x N adjacency network into S x S — collapse_network","text":"list rows, columns, weights","code":""},{"path":"/reference/decompose_network.html","id":null,"dir":"Reference","previous_headings":"","what":"Assign best topic membership for the edges — decompose_network","title":"Assign best topic membership for the edges — decompose_network","text":"Assign best topic membership edges","code":""},{"path":"/reference/decompose_network.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assign best topic membership for the edges — decompose_network","text":"","code":"decompose_network(A_dd, beta_dt, cutoff = 1e-08, verbose = TRUE)"},{"path":"/reference/decompose_network.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assign best topic membership for the edges — decompose_network","text":"A_dd D x D adjacency matrix beta_dt D x T node propensity matrix cutoff Ai,j cutoff (default: 1e-8) verbose verbosity","code":""},{"path":"/reference/fileset.list.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a list of MTX-related files — fileset.list","title":"Create a list of MTX-related files — fileset.list","text":"Create list MTX-related files","code":""},{"path":"/reference/fileset.list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a list of MTX-related files — fileset.list","text":"","code":"fileset.list(.hdr)"},{"path":"/reference/fileset.list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a list of MTX-related files — fileset.list","text":".hdr file set header name","code":""},{"path":"/reference/fileset.list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a list of MTX-related files — fileset.list","text":"list file names","code":""},{"path":"/reference/fit_poisson_cluster_rows.html","id":null,"dir":"Reference","previous_headings":"","what":"Clustering the rows of a count data matrix — fit_poisson_cluster_rows","title":"Clustering the rows of a count data matrix — fit_poisson_cluster_rows","text":"Clustering rows count data matrix","code":""},{"path":"/reference/fit_poisson_cluster_rows.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clustering the rows of a count data matrix — fit_poisson_cluster_rows","text":"","code":"fit_poisson_cluster_rows(   X,   Ltrunc,   alpha = 1,   a0 = 0.01,   b0 = 1e-04,   rseed = 42L,   mcmc = 100L,   burnin = 10L,   verbose = TRUE )"},{"path":"/reference/fit_poisson_cluster_rows.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clustering the rows of a count data matrix — fit_poisson_cluster_rows","text":"X data matrix Ltrunc DPM truncation level alpha DPM parameter a0 prior ~ Gamma(a0, b0) (default: 1e-2) b0 prior ~ Gamma(a0, b0) (default: 1e-4) rseed random seed (default: 42) mcmc number MCMC iterations (default: 100) burnin number iterations discard (default: 10) verbose verbosity","code":""},{"path":"/reference/mmutil_build_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an index file for a given MTX — mmutil_build_index","title":"Create an index file for a given MTX — mmutil_build_index","text":"Create index file given MTX","code":""},{"path":"/reference/mmutil_build_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an index file for a given MTX — mmutil_build_index","text":"","code":"mmutil_build_index(mtx_file, index_file)"},{"path":"/reference/mmutil_build_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an index file for a given MTX — mmutil_build_index","text":"mtx_file data file index_file index file","code":""},{"path":"/reference/mmutil_build_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an index file for a given MTX — mmutil_build_index","text":"EXIT_SUCCESS EXIT_FAILURE","code":""},{"path":"/reference/mmutil_check_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if the index tab is valid — mmutil_check_index","title":"Check if the index tab is valid — mmutil_check_index","text":"Check index tab valid","code":""},{"path":"/reference/mmutil_check_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if the index tab is valid — mmutil_check_index","text":"","code":"mmutil_check_index(mtx_file, index_tab)"},{"path":"/reference/mmutil_check_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if the index tab is valid — mmutil_check_index","text":"mtx_file data file index_tab index tab (vector memory locations)","code":""},{"path":"/reference/mmutil_check_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if the index tab is valid — mmutil_check_index","text":"TRUE FALSE","code":""},{"path":"/reference/mmutil_colnames.html","id":null,"dir":"Reference","previous_headings":"","what":"Just read each col name per line — mmutil_colnames","title":"Just read each col name per line — mmutil_colnames","text":"Just read col name per line","code":""},{"path":"/reference/mmutil_colnames.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Just read each col name per line — mmutil_colnames","text":"","code":"mmutil_colnames(col_file, MAX_COL_WORD = 100L, COL_WORD_SEP = \"@\")"},{"path":"/reference/mmutil_colnames.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Just read each col name per line — mmutil_colnames","text":"col_file data file","code":""},{"path":"/reference/mmutil_colnames.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Just read each col name per line — mmutil_colnames","text":"colnames","code":""},{"path":"/reference/mmutil_copy_selected_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Take a subset of columns and create a new MTX file-set — mmutil_copy_selected_columns","title":"Take a subset of columns and create a new MTX file-set — mmutil_copy_selected_columns","text":"Take subset columns create new MTX file-set","code":""},{"path":"/reference/mmutil_copy_selected_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Take a subset of columns and create a new MTX file-set — mmutil_copy_selected_columns","text":"","code":"mmutil_copy_selected_columns(   mtx_file,   row_file,   col_file,   r_selected,   output,   MAX_COL_WORD = 100L,   COL_WORD_SEP = \"@\" )"},{"path":"/reference/mmutil_copy_selected_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Take a subset of columns and create a new MTX file-set — mmutil_copy_selected_columns","text":"mtx_file data file row_file row file col_file column file output output header MAX_COL_WORD maximum words per line col_file COL_WORD_SEP word separation character replace white space selected selected column names","code":""},{"path":"/reference/mmutil_copy_selected_columns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Take a subset of columns and create a new MTX file-set — mmutil_copy_selected_columns","text":"","code":"options(stringsAsFactors=FALSE) rr <- rgamma(20, 1, 1) mm <- matrix(rgamma(10 * 2, 1, 1), 10, 2) src.hdr <- \"test_org\" src.files <- mmutil_simulate_poisson(mm, rr, src.hdr) Y <- Matrix::readMM(src.files$mtx) colnames(Y) <- read.table(src.files$col)$V1 print(Y) #> 10 x 17 sparse Matrix of class \"dgTMatrix\" #>   [[ suppressing 17 column names ‘1’, ‘2’, ‘3’ ... ]] #>                                              #>  [1,] 2 . 2 .  1  . . .  4  2 .  1 . . . 3 2 #>  [2,] . . . .  .  1 . 1  2  . 1  1 . . . . . #>  [3,] . 1 . .  .  2 1 .  1  . .  2 . . 1 1 . #>  [4,] . 1 . .  1  1 . .  .  . .  . . . . . . #>  [5,] . . . .  .  2 . .  .  . .  . 1 . . . . #>  [6,] . . . .  .  . . .  .  1 .  . . . . 1 2 #>  [7,] 5 4 3 .  3  5 3 . 12  4 . 10 . 1 . 2 1 #>  [8,] . . . .  1  . . .  .  . .  . 2 . . . . #>  [9,] 4 2 7 2 14 11 3 3 16 15 2 12 . . . 3 . #> [10,] 1 . 1 1  1  1 . .  .  1 .  1 . . 1 . 4 sub.cols <- sort(read.table(src.files$col)$V1[sample(20,3)]) print(sub.cols) #> [1]  1  5 11 tgt.hdr <- \"test_sub\" tgt.files <- mmutil_copy_selected_columns(                          src.files$mtx,                          src.files$row,                          src.files$col,                          sub.cols, tgt.hdr) Y <- Matrix::readMM(tgt.files$mtx) colnames(Y) <- read.table(tgt.files$col)$V1 print(Y) #> 10 x 3 sparse Matrix of class \"dgTMatrix\" #>       1  5 11 #>  [1,] 2  1  . #>  [2,] .  .  1 #>  [3,] .  .  . #>  [4,] .  1  . #>  [5,] .  .  . #>  [6,] .  .  . #>  [7,] 5  3  . #>  [8,] .  1  . #>  [9,] 4 14  2 #> [10,] 1  1  . unlink(list.files(pattern = src.hdr)) unlink(list.files(pattern = tgt.hdr))"},{"path":"/reference/mmutil_copy_selected_rows.html","id":null,"dir":"Reference","previous_headings":"","what":"Take a subset of rows and create a new MTX file-set — mmutil_copy_selected_rows","title":"Take a subset of rows and create a new MTX file-set — mmutil_copy_selected_rows","text":"new mtx file, empty columns zero elements removed.","code":""},{"path":"/reference/mmutil_copy_selected_rows.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Take a subset of rows and create a new MTX file-set — mmutil_copy_selected_rows","text":"","code":"mmutil_copy_selected_rows(   mtx_file,   row_file,   col_file,   r_selected,   output,   MAX_ROW_WORD = 2L,   ROW_WORD_SEP = \"_\",   MAX_COL_WORD = 100L,   COL_WORD_SEP = \"@\" )"},{"path":"/reference/mmutil_copy_selected_rows.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Take a subset of rows and create a new MTX file-set — mmutil_copy_selected_rows","text":"mtx_file data file row_file row file col_file column file output output header MAX_ROW_WORD maximum words per line row_file ROW_WORD_SEP word separation character replace white space selected selected row names","code":""},{"path":"/reference/mmutil_copy_selected_rows.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Take a subset of rows and create a new MTX file-set — mmutil_copy_selected_rows","text":"list file names: output.mtx,rows,cols.gz","code":""},{"path":"/reference/mmutil_copy_selected_rows.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Take a subset of rows and create a new MTX file-set — mmutil_copy_selected_rows","text":"","code":"options(stringsAsFactors=FALSE) rr <- rgamma(20, 1, 1) mm <- matrix(rgamma(10 * 2, 1, 1), 10, 2) src.hdr <- \"test_org\" src.files <- mmutil_simulate_poisson(mm, rr, src.hdr) Y <- Matrix::readMM(src.files$mtx) rownames(Y) <- read.table(src.files$row)$V1 print(Y) #> 10 x 18 sparse Matrix of class \"dgTMatrix\" #>                                         #> r01 5 . 1 1 2 . 2 . . . 1 4 4 3 3 . . . #> r02 3 . . 1 4 1 . 1 . 1 1 . . . . . . . #> r03 1 1 . . 1 . . . . . 2 2 1 2 8 2 2 2 #> r04 . . . . . . . . . . . . 1 2 1 . 1 . #> r05 . . . . . . . . . . . . . . . . . . #> r06 . . . . . . . . . . . . 2 . 2 1 . . #> r07 2 1 . . . . . . . . . 1 . 1 1 . 1 . #> r08 3 . . 3 3 1 2 . 1 . 4 2 2 5 4 2 . . #> r09 4 . . 4 2 1 1 . . 1 1 5 . . 3 . . . #> r10 . . . . 1 . . . . . . . 3 3 6 . . . sub.rows <- sort(read.table(src.files$row)$V1[sample(10,3)]) print(sub.rows) #> [1] \"r01\" \"r09\" \"r10\" tgt.hdr <- \"test_sub\" tgt.files <- mmutil_copy_selected_rows(                src.files$mtx,                src.files$row,                src.files$col,                sub.rows,                tgt.hdr) Y <- Matrix::readMM(tgt.files$mtx) colnames(Y) <- read.table(tgt.files$col)$V1 rownames(Y) <- read.table(tgt.files$row)$V1 print(Y) #> 3 x 12 sparse Matrix of class \"dgTMatrix\" #>   [[ suppressing 12 column names ‘1’, ‘3’, ‘5’ ... ]] #>                             #> r01 5 1 1 2 . 2 . 1 4 4 3 3 #> r09 4 . 4 2 1 1 1 1 5 . . 3 #> r10 . . . 1 . . . . . 3 3 6 unlink(list.files(pattern = src.hdr)) unlink(list.files(pattern = tgt.hdr))"},{"path":"/reference/mmutil_info.html","id":null,"dir":"Reference","previous_headings":"","what":"Just read the header information — mmutil_info","title":"Just read the header information — mmutil_info","text":"Just read header information","code":""},{"path":"/reference/mmutil_info.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Just read the header information — mmutil_info","text":"","code":"mmutil_info(mtx_file)"},{"path":"/reference/mmutil_info.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Just read the header information — mmutil_info","text":"mtx_file data file","code":""},{"path":"/reference/mmutil_info.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Just read the header information — mmutil_info","text":"info","code":""},{"path":"/reference/mmutil_read_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Read a subset of columns from the data matrix — mmutil_read_columns","title":"Read a subset of columns from the data matrix — mmutil_read_columns","text":"Read subset columns data matrix","code":""},{"path":"/reference/mmutil_read_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read a subset of columns from the data matrix — mmutil_read_columns","text":"","code":"mmutil_read_columns(mtx_file, memory_location, r_column_index, verbose = FALSE)"},{"path":"/reference/mmutil_read_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read a subset of columns from the data matrix — mmutil_read_columns","text":"mtx_file data file memory_location column -> memory location r_column_index column indexes retrieve (1-based)","code":""},{"path":"/reference/mmutil_read_columns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read a subset of columns from the data matrix — mmutil_read_columns","text":"dense sub-matrix","code":""},{"path":"/reference/mmutil_read_columns_sparse.html","id":null,"dir":"Reference","previous_headings":"","what":"Read a subset of columns from the data matrix — mmutil_read_columns_sparse","title":"Read a subset of columns from the data matrix — mmutil_read_columns_sparse","text":"Read subset columns data matrix","code":""},{"path":"/reference/mmutil_read_columns_sparse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read a subset of columns from the data matrix — mmutil_read_columns_sparse","text":"","code":"mmutil_read_columns_sparse(   mtx_file,   memory_location,   r_column_index,   verbose = FALSE )"},{"path":"/reference/mmutil_read_columns_sparse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read a subset of columns from the data matrix — mmutil_read_columns_sparse","text":"mtx_file data file memory_location column -> memory location r_column_index column indexes retrieve (1-based)","code":""},{"path":"/reference/mmutil_read_columns_sparse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read a subset of columns from the data matrix — mmutil_read_columns_sparse","text":"lists rows, columns, values","code":""},{"path":"/reference/mmutil_read_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Read an index file to R — mmutil_read_index","title":"Read an index file to R — mmutil_read_index","text":"Read index file R","code":""},{"path":"/reference/mmutil_read_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read an index file to R — mmutil_read_index","text":"","code":"mmutil_read_index(index_file)"},{"path":"/reference/mmutil_read_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read an index file to R — mmutil_read_index","text":"index_file index file","code":""},{"path":"/reference/mmutil_read_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read an index file to R — mmutil_read_index","text":"vector column index (vector memory locations)","code":""},{"path":"/reference/mmutil_read_rows_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Read a subset of rows and columns from the data matrix — mmutil_read_rows_columns","title":"Read a subset of rows and columns from the data matrix — mmutil_read_rows_columns","text":"Read subset rows columns data matrix","code":""},{"path":"/reference/mmutil_read_rows_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read a subset of rows and columns from the data matrix — mmutil_read_rows_columns","text":"","code":"mmutil_read_rows_columns(   mtx_file,   memory_location,   r_row_index,   r_column_index,   verbose = FALSE )"},{"path":"/reference/mmutil_read_rows_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read a subset of rows and columns from the data matrix — mmutil_read_rows_columns","text":"mtx_file data file memory_location column -> memory location r_row_index row indexes retrieve (1-based) r_column_index column indexes retrieve (1-based) verbose verbosity","code":""},{"path":"/reference/mmutil_read_rows_columns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read a subset of rows and columns from the data matrix — mmutil_read_rows_columns","text":"dense sub-matrix","code":""},{"path":"/reference/mmutil_rownames.html","id":null,"dir":"Reference","previous_headings":"","what":"Just read each row name per line — mmutil_rownames","title":"Just read each row name per line — mmutil_rownames","text":"Just read row name per line","code":""},{"path":"/reference/mmutil_rownames.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Just read each row name per line — mmutil_rownames","text":"","code":"mmutil_rownames(row_file, MAX_ROW_WORD = 2L, ROW_WORD_SEP = \"_\")"},{"path":"/reference/mmutil_rownames.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Just read each row name per line — mmutil_rownames","text":"row_file data file","code":""},{"path":"/reference/mmutil_rownames.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Just read each row name per line — mmutil_rownames","text":"rownames","code":""},{"path":"/reference/mmutil_simulate_poisson.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulation Poisson data based on Mu — mmutil_simulate_poisson","title":"Simulation Poisson data based on Mu — mmutil_simulate_poisson","text":"M= num. features n= num. indv","code":""},{"path":"/reference/mmutil_simulate_poisson.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulation Poisson data based on Mu — mmutil_simulate_poisson","text":"","code":"mmutil_simulate_poisson(   mu,   rho,   output,   r_indv = NULL,   rseed = 42L,   MAX_COL_WORD = 100L,   COL_WORD_SEP = \"@\" )"},{"path":"/reference/mmutil_simulate_poisson.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulation Poisson data based on Mu — mmutil_simulate_poisson","text":"mu depth-adjusted mean matrix (M x n) rho column depth vector (N x 1), N= num. cells output header $output.mtx.gz,cols.gz,indv.gz r_indv N x 1 individual membership (1-based, 1 .. n) rseed random seed","code":""},{"path":"/reference/mmutil_simulate_poisson.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulation Poisson data based on Mu — mmutil_simulate_poisson","text":"list file names: output.mtx,rows,cols.gz","code":""},{"path":"/reference/mmutil_simulate_poisson_mixture.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate sparse counting data with a mixture of Poisson parameters — mmutil_simulate_poisson_mixture","title":"Simulate sparse counting data with a mixture of Poisson parameters — mmutil_simulate_poisson_mixture","text":"Simulate sparse counting data mixture Poisson parameters","code":""},{"path":"/reference/mmutil_simulate_poisson_mixture.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate sparse counting data with a mixture of Poisson parameters — mmutil_simulate_poisson_mixture","text":"","code":"mmutil_simulate_poisson_mixture(   r_mu_list,   Ncell,   output,   dir_alpha = 1,   gam_alpha = 2,   gam_beta = 2,   rseed = 42L,   MAX_COL_WORD = 100L,   COL_WORD_SEP = \"@\" )"},{"path":"/reference/mmutil_simulate_poisson_mixture.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate sparse counting data with a mixture of Poisson parameters — mmutil_simulate_poisson_mixture","text":"r_mu_list list gene x individual matrices Ncell total number cells (may make sparse) output file header string output files dir_alpha parameter Dirichlet(alpha * 1, ..., 1) gam_alpha parameter Gamma(alpha, beta) gam_beta parameter Gamma(alpha, beta) rseed random seed","code":""},{"path":"/reference/mmutil_write_mtx.html","id":null,"dir":"Reference","previous_headings":"","what":"Write down sparse matrix to the disk — mmutil_write_mtx","title":"Write down sparse matrix to the disk — mmutil_write_mtx","text":"Write sparse matrix disk","code":""},{"path":"/reference/mmutil_write_mtx.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write down sparse matrix to the disk — mmutil_write_mtx","text":"","code":"mmutil_write_mtx(X, mtx_file)"},{"path":"/reference/mmutil_write_mtx.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write down sparse matrix to the disk — mmutil_write_mtx","text":"X sparse matrix mtx_file file name","code":""},{"path":"/reference/mmutil_write_mtx.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write down sparse matrix to the disk — mmutil_write_mtx","text":"EXIT_SUCCESS EXIT_FAILURE","code":""},{"path":"/reference/pmf2topic.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Poisson Matrix Factorization to Multinomial Topic model. The same idea was first coined by fastTopics paper. — pmf2topic","title":"Convert Poisson Matrix Factorization to Multinomial Topic model. The same idea was first coined by fastTopics paper. — pmf2topic","text":"Convert Poisson Matrix Factorization Multinomial Topic model. idea first coined fastTopics paper.","code":""},{"path":"/reference/pmf2topic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Poisson Matrix Factorization to Multinomial Topic model. The same idea was first coined by fastTopics paper. — pmf2topic","text":"","code":"pmf2topic(.beta, .theta, eps = 1e-08)"},{"path":"/reference/pmf2topic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Poisson Matrix Factorization to Multinomial Topic model. The same idea was first coined by fastTopics paper. — pmf2topic","text":".beta D x K dictionary matrix .theta N x K sample-wise factor loading matrix","code":""},{"path":"/reference/pmf2topic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Poisson Matrix Factorization to Multinomial Topic model. The same idea was first coined by fastTopics paper. — pmf2topic","text":"list (beta, prop, depth), beta re-scaled dictionary matrix, row prop matrix corresponds mixing proportion per column, depth parameter gauges sequencing depth column","code":""},{"path":"/reference/pmf2topic.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert Poisson Matrix Factorization to Multinomial Topic model. The same idea was first coined by fastTopics paper. — pmf2topic","text":"EY|.beta, .theta = .beta %*% t(.theta)","code":""},{"path":"/reference/project.proportions.html","id":null,"dir":"Reference","previous_headings":"","what":"Create 2D projection of topic proportions — project.proportions","title":"Create 2D projection of topic proportions — project.proportions","text":"Create 2D projection topic proportions","code":""},{"path":"/reference/project.proportions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create 2D projection of topic proportions — project.proportions","text":"","code":"project.proportions(.prop, max.angle = 2 * pi, do.jitter = TRUE)"},{"path":"/reference/project.proportions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create 2D projection of topic proportions — project.proportions","text":".prop cell/sample x topic/factor proportion matrix max.angle maximum angle .jitter jitter points","code":""},{"path":"/reference/project.proportions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create 2D projection of topic proportions — project.proportions","text":"xy","code":""},{"path":"/reference/rbind.mtx.html","id":null,"dir":"Reference","previous_headings":"","what":"A wrapper function that concatenates two files vertically — rbind.mtx","title":"A wrapper function that concatenates two files vertically — rbind.mtx","text":"wrapper function concatenates two files vertically","code":""},{"path":"/reference/rbind.mtx.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A wrapper function that concatenates two files vertically — rbind.mtx","text":"","code":"# S3 method for class 'mtx' rbind(top.hdr, bottom.hdr, out.hdr)"},{"path":"/reference/rbind.mtx.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A wrapper function that concatenates two files vertically — rbind.mtx","text":"top.hdr file header top files bottom.hdr file header bottom files .hdr output file header","code":""},{"path":"/reference/rbind.mtx.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A wrapper function that concatenates two files vertically — rbind.mtx","text":"list resulting file names","code":""},{"path":"/reference/read.mtx.dense.html","id":null,"dir":"Reference","previous_headings":"","what":"A wrapper function to read a dense submatrix — read.mtx.dense","title":"A wrapper function to read a dense submatrix — read.mtx.dense","text":"wrapper function read dense submatrix","code":""},{"path":"/reference/read.mtx.dense.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A wrapper function to read a dense submatrix — read.mtx.dense","text":"","code":"read.mtx.dense(   mtx.file,   sub.cols = NULL,   memory.idx = NULL,   memory.idx.file = paste0(mtx.file, \".index\"),   verbose = FALSE )"},{"path":"/reference/read.mtx.dense.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A wrapper function to read a dense submatrix — read.mtx.dense","text":"mtx.file matrix market file sub.cols column index (default: ) memory.idx memory locations memory.idx.file memory location file verbose verbosity","code":""},{"path":"/reference/read.mtx.dense.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A wrapper function to read a dense submatrix — read.mtx.dense","text":"dense matrix","code":""},{"path":"/reference/read.mtx.sparse.html","id":null,"dir":"Reference","previous_headings":"","what":"A wrapper function to read a sparse submatrix — read.mtx.sparse","title":"A wrapper function to read a sparse submatrix — read.mtx.sparse","text":"wrapper function read sparse submatrix","code":""},{"path":"/reference/read.mtx.sparse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A wrapper function to read a sparse submatrix — read.mtx.sparse","text":"","code":"read.mtx.sparse(   mtx.file,   sub.cols = NULL,   memory.idx = NULL,   memory.idx.file = paste0(mtx.file, \".index\"),   verbose = FALSE )"},{"path":"/reference/read.mtx.sparse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A wrapper function to read a sparse submatrix — read.mtx.sparse","text":"mtx.file matrix market file sub.cols column index (default: ) memory.idx memory locations memory.idx.file memory location file verbose verbosity","code":""},{"path":"/reference/read.mtx.sparse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A wrapper function to read a sparse submatrix — read.mtx.sparse","text":"sparse matrix","code":""},{"path":"/reference/read.vec.html","id":null,"dir":"Reference","previous_headings":"","what":"Read a vector of string names — read.vec","title":"Read a vector of string names — read.vec","text":"Read vector string names","code":""},{"path":"/reference/read.vec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read a vector of string names — read.vec","text":"","code":"read.vec(.file)"},{"path":"/reference/read.vec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read a vector of string names — read.vec","text":".file file name","code":""},{"path":"/reference/read.vec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read a vector of string names — read.vec","text":"vector strings","code":""},{"path":"/reference/write.sparse.html","id":null,"dir":"Reference","previous_headings":"","what":"Write matrix market file set — write.sparse","title":"Write matrix market file set — write.sparse","text":"Write matrix market file set","code":""},{"path":"/reference/write.sparse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write matrix market file set — write.sparse","text":"","code":"write.sparse(out.mtx, out.rows, out.cols, output)"},{"path":"/reference/write.sparse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write matrix market file set — write.sparse","text":".mtx sparse matrix .rows vector rows .cols vector columns output output file set header","code":""}]
