# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' A quick NMF estimation based on alternating Poisson regressions
#'
#' @param Y_ non-negative data matrix (gene x sample)
#' @param maxK maximum number of factors
#' @param max_iter max number of optimization steps
#' @param min_iter min number of optimization steps
#' @param burnin number of initiation steps
#' @param verbose verbosity
#' @param a0 gamma(a0, b0) default: a0 = 1
#' @param b0 gamma(a0, b0) default: b0 = 1
#' @param do_scale scale each column by standard deviation (default: TRUE)
#' @param do_log1p do log(1+y) transformation
#' @param rseed random seed (default: 1337)
#' @param svd_init initialize by SVD (default: TRUE)
#' @param EPS (default: 1e-4)
#'
#' @return a list that contains:
#'  \itemize{
#'   \item log.likelihood log-likelihood trace
#'   \item beta dictionary (gene x factor)
#'   \item log.beta log-dictionary (gene x factor)
#'   \item theta loading (sample x factor)
#'   \item log.theta log-loading (sample x factor)
#'   \item log.phi auxiliary variables (gene x factor)
#'   \item log.rho auxiliary variables (sample x factor)
#' }
#'
#'
asap_fit_nmf_alternate <- function(Y_, maxK, max_iter = 100L, burnin = 10L, verbose = TRUE, a0 = 1, b0 = 1, do_scale = TRUE, do_log1p = FALSE, rseed = 1337L, svd_init = TRUE, EPS = 1e-4) {
    .Call('_asapR_asap_fit_nmf_alternate', PACKAGE = 'asapR', Y_, maxK, max_iter, burnin, verbose, a0, b0, do_scale, do_log1p, rseed, svd_init, EPS)
}

#' Generate approximate pseudo-bulk data by random projections
#'
#' @param mtx_file matrix-market-formatted data file (bgzip)
#' @param mtx_idx_file matrix-market colum index file
#' @param num_factors a desired number of random factors
#' @param r_covar covariates (default: NULL)
#' @param r_batch batch information (default: NULL)
#' @param rseed random seed
#' @param verbose verbosity
#' @param NUM_THREADS number of threads in data reading
#' @param BLOCK_SIZE disk I/O block size (number of columns)
#' @param do_scale scale each column by standard deviation (default: TRUE)
#' @param do_log1p log(x + 1) transformation (default: FALSE)
#' @param do_row_std rowwise standardization (default: FALSE)
#' @param KNN_CELL k-NN matching between cells (default: 10)
#' @param BATCH_ADJ_ITER batch Adjustment steps (default: 100)
#' @param a0 gamma(a0, b0) (default: 1)
#' @param b0 gamma(a0, b0) (default: 1)
#'
asap_random_bulk_data <- function(mtx_file, mtx_idx_file, num_factors, r_covar = NULL, r_batch = NULL, rseed = 42L, verbose = FALSE, NUM_THREADS = 1L, BLOCK_SIZE = 100L, do_scale = FALSE, do_log1p = FALSE, do_row_std = FALSE, KNN_CELL = 10L, BATCH_ADJ_ITER = 100L, a0 = 1, b0 = 1) {
    .Call('_asapR_asap_random_bulk_data', PACKAGE = 'asapR', mtx_file, mtx_idx_file, num_factors, r_covar, r_batch, rseed, verbose, NUM_THREADS, BLOCK_SIZE, do_scale, do_log1p, do_row_std, KNN_CELL, BATCH_ADJ_ITER, a0, b0)
}

#' Poisson regression to estimate factor loading
#'
#' @param Y D x N data matrix
#' @param log_x D x K log dictionary/design matrix
#' @param r_batch_effect D x B batch effect matrix (default: NULL)
#' @param a0 gamma(a0, b0) (default: 1)
#' @param b0 gamma(a0, b0) (default: 1)
#' @param do_scale scale each column by standard deviation (default: TRUE)
#' @param do_log1p do log(1+y) transformation (default: FALSE)
#' @param verbose verbosity (default: false)
#' @param do_stdize do the standardization of log_x
#'
asap_regression <- function(Y_, log_x, r_batch_effect = NULL, a0 = 1., b0 = 1., max_iter = 10L, do_scale = FALSE, do_log1p = FALSE, verbose = TRUE, do_stdize_x = FALSE) {
    .Call('_asapR_asap_regression', PACKAGE = 'asapR', Y_, log_x, r_batch_effect, a0, b0, max_iter, do_scale, do_log1p, verbose, do_stdize_x)
}

#' Poisson regression to estimate factor loading
#'
#' @param mtx_file matrix-market-formatted data file (D x N, bgzip)
#' @param mtx_idx_file matrix-market colum index file
#' @param log_x D x K log dictionary/design matrix
#' @param r_batch_effect D x B batch effect matrix (default: NULL)
#' @param r_x_row_names (default: NULL)
#' @param r_mtx_row_names (default: NULL)
#' @param a0 gamma(a0, b0)
#' @param b0 gamma(a0, b0)
#' @param do_scale scale each column by standard deviation (default: TRUE)
#' @param do_log1p do log(1+y) transformation
#' @param verbose verbosity
#' @param NUM_THREADS number of threads in data reading
#' @param BLOCK_SIZE disk I/O block size (number of columns)
#' @param do_stdize do the standardization of log_x
#'
asap_regression_mtx <- function(mtx_file, mtx_idx_file, log_x, r_batch_effect = NULL, r_x_row_names = NULL, r_mtx_row_names = NULL, r_taboo_names = NULL, a0 = 1., b0 = 1., max_iter = 10L, do_scale = FALSE, do_log1p = FALSE, verbose = FALSE, NUM_THREADS = 1L, BLOCK_SIZE = 100L, do_stdize_x = FALSE) {
    .Call('_asapR_asap_regression_mtx', PACKAGE = 'asapR', mtx_file, mtx_idx_file, log_x, r_batch_effect, r_x_row_names, r_mtx_row_names, r_taboo_names, a0, b0, max_iter, do_scale, do_log1p, verbose, NUM_THREADS, BLOCK_SIZE, do_stdize_x)
}

#' Clustering the rows of a count data matrix
#'
#' @param X data matrix
#' @param Ltrunc DPM truncation level
#' @param alpha DPM parameter
#' @param a0 prior ~ Gamma(a0, b0) (default: 1e-2)
#' @param b0 prior ~ Gamma(a0, b0) (default: 1e-4)
#' @param rseed random seed (default: 42)
#' @param mcmc number of MCMC iterations (default: 100)
#' @param burnin number iterations to discard (default: 10)
#' @param verbose verbosity
#'
fit_poisson_cluster_rows <- function(X, Ltrunc, alpha = 1, a0 = 1e-2, b0 = 1e-4, rseed = 42L, mcmc = 100L, burnin = 10L, verbose = TRUE) {
    .Call('_asapR_fit_poisson_cluster_rows', PACKAGE = 'asapR', X, Ltrunc, alpha, a0, b0, rseed, mcmc, burnin, verbose)
}

#' Create an index file for a given MTX
#'
#' @param mtx_file data file
#' @param index_file index file
#'
#' @usage mmutil_build_index(mtx_file, index_file)
#'
#' @return EXIT_SUCCESS or EXIT_FAILURE
#'
mmutil_build_index <- function(mtx_file, index_file = "") {
    .Call('_asapR_mmutil_build_index', PACKAGE = 'asapR', mtx_file, index_file)
}

#' Read an index file to R
#'
#' @param index_file index file
#'
#' @return a vector column index (a vector of memory locations)
#'
mmutil_read_index <- function(index_file) {
    .Call('_asapR_mmutil_read_index', PACKAGE = 'asapR', index_file)
}

#' Check if the index tab is valid
#'
#' @param mtx_file data file
#' @param index_tab index tab (a vector of memory locations)
#'
#' @return TRUE or FALSE
#'
mmutil_check_index <- function(mtx_file, index_tab) {
    .Call('_asapR_mmutil_check_index', PACKAGE = 'asapR', mtx_file, index_tab)
}

#' Just read the header information
#'
#' @param mtx_file data file
#'
#' @return info
#'
mmutil_info <- function(mtx_file) {
    .Call('_asapR_mmutil_info', PACKAGE = 'asapR', mtx_file)
}

#' Write down sparse matrix to the disk
#' @param X sparse matrix
#' @param mtx_file file name
#'
#' @return EXIT_SUCCESS or EXIT_FAILURE
mmutil_write_mtx <- function(X, mtx_file) {
    .Call('_asapR_mmutil_write_mtx', PACKAGE = 'asapR', X, mtx_file)
}

#' Read a subset of columns from the data matrix
#' @param mtx_file data file
#' @param memory_location column -> memory location
#' @param r_column_index column indexes to retrieve (1-based)
#'
#' @return lists of rows, columns, values
#'
mmutil_read_columns_sparse <- function(mtx_file, memory_location, r_column_index, verbose = FALSE) {
    .Call('_asapR_mmutil_read_columns_sparse', PACKAGE = 'asapR', mtx_file, memory_location, r_column_index, verbose)
}

#' Read a subset of columns from the data matrix
#' @param mtx_file data file
#' @param memory_location column -> memory location
#' @param r_column_index column indexes to retrieve (1-based)
#'
#' @return a dense sub-matrix
#'
#' @examples
#'
#' rr <- rgamma(100, 1, 1) # one hundred cells
#' mm <- matrix(rgamma(10 * 3, 1, 1), 10, 3)
#' data.hdr <- "test_sim"
#' .files <- asapR::mmutil_simulate_poisson(mm, rr, data.hdr)
#' data.file <- .files$mtx
#' idx.file <- .files$idx
#' mtx.idx <- asapR::mmutil_read_index(idx.file)
#' Y <- as.matrix(Matrix::readMM(data.file))
#' col.pos <- c(1,13,77) # 1-based
#' yy <- asapR::mmutil_read_columns(
#'                  data.file, mtx.idx, col.pos)
#' all(Y[, col.pos, drop = FALSE] == yy)
#' print(head(Y[, col.pos, drop = FALSE]))
#' print(head(yy))
#' unlink(list.files(pattern = data.hdr))
#'
mmutil_read_columns <- function(mtx_file, memory_location, r_column_index, verbose = FALSE) {
    .Call('_asapR_mmutil_read_columns', PACKAGE = 'asapR', mtx_file, memory_location, r_column_index, verbose)
}

#' Read a subset of rows and columns from the data matrix
#' @param mtx_file data file
#' @param memory_location column -> memory location
#' @param r_row_index row indexes to retrieve (1-based)
#' @param r_column_index column indexes to retrieve (1-based)
#' @param verbose verbosity
#'
#' @return a dense sub-matrix
#'
#' @examples
#'
#' rr <- rgamma(100, 1, 1) # one hundred cells
#' mm <- matrix(rgamma(10 * 3, 1, 1), 10, 3)
#' data.hdr <- "test_sim"
#' .files <- asapR::mmutil_simulate_poisson(mm, rr, data.hdr)
#' data.file <- .files$mtx
#' idx.file <- .files$idx
#' mtx.idx <- asapR::mmutil_read_index(idx.file)
#' Y <- as.matrix(Matrix::readMM(data.file))
#' col.pos <- c(1,13,77) # 1-based
#' row.pos <- 1:10
#' yy <- asapR::mmutil_read_rows_columns(
#'                  data.file, mtx.idx, row.pos, col.pos)
#' all(Y[, col.pos, drop = FALSE] == yy)
#' print(head(Y[, col.pos, drop = FALSE]))
#' print(head(yy))
#' print(tail(yy))
#' unlink(list.files(pattern = data.hdr))
#'
mmutil_read_rows_columns <- function(mtx_file, memory_location, r_row_index, r_column_index, verbose = FALSE) {
    .Call('_asapR_mmutil_read_rows_columns', PACKAGE = 'asapR', mtx_file, memory_location, r_row_index, r_column_index, verbose)
}

#' Simulate sparse counting data with a mixture of Poisson parameters
#'
#'
#' @param r_mu_list a list of gene x individual matrices
#' @param Ncell the total number of cells (may not make it if too sparse)
#' @param output a file header string for output files
#' @param dir_alpha a parameter for Dirichlet(alpha * [1, ..., 1])
#' @param gam_alpha a parameter for Gamma(alpha, beta)
#' @param gam_beta a parameter for Gamma(alpha, beta)
#' @param rseed random seed
#'
mmutil_simulate_poisson_mixture <- function(r_mu_list, Ncell, output, dir_alpha = 1.0, gam_alpha = 2.0, gam_beta = 2.0, rseed = 42L) {
    .Call('_asapR_mmutil_simulate_poisson_mixture', PACKAGE = 'asapR', r_mu_list, Ncell, output, dir_alpha, gam_alpha, gam_beta, rseed)
}

#' Simulation Poisson data based on Mu
#'
#' M= num. of features and n= num. of indv
#'
#' @param mu depth-adjusted mean matrix (M x n)
#' @param rho column depth vector (N x 1), N= num. of cells
#' @param output header for ${output}.{mtx.gz,cols.gz,indv.gz}
#' @param r_indv N x 1 individual membership (1-based, [1 .. n])
#' @param rseed random seed
#'
#' @return a list of file names: {output}.{mtx,rows,cols}.gz
#'
mmutil_simulate_poisson <- function(mu, rho, output, r_indv = NULL, rseed = 42L) {
    .Call('_asapR_mmutil_simulate_poisson', PACKAGE = 'asapR', mu, rho, output, r_indv, rseed)
}

