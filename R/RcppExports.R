# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Predict NMF loading -- this may be slow for high-dim data
#'
#' @param mtx_file matrix-market-formatted data file (bgzip)
#' @param memory_location column indexing for the mtx
#' @param beta row x factor dictionary
#' @param mcem number of Monte Carlo Expectation Maximization
#' @param burnin burn-in period
#' @param thining thining interval in record keeping
#' @param a0 gamma(a0, b0)
#' @param b0 gamma(a0, b0)
#' @param rseed random seed
#' @param verbose verbosity
#' @param NUM_THREADS number of threads in data reading
#' @param BLOCK_SIZE disk I/O block size (number of columns)
#'
asap_predict_mtx <- function(mtx_file, memory_location, beta, mcem = 100L, burnin = 10L, thining = 3L, a0 = 1., b0 = 1., rseed = 42L, verbose = FALSE, NUM_THREADS = 1L, BLOCK_SIZE = 100L) {
    .Call('_asapR_asap_predict_mtx', PACKAGE = 'asapR', mtx_file, memory_location, beta, mcem, burnin, thining, a0, b0, rseed, verbose, NUM_THREADS, BLOCK_SIZE)
}

#' Non-negative matrix factorization
#'
#' @param Y data matrix (gene x sample)
#' @param maxK maximum number of factors
#' @param mcem number of Monte Carl Expectation Maximization
#' @param burnin burn-in period
#' @param latent_iter latent sampling steps
#' @param degree_iter row and column degree optimization steps
#' @param thining thining interval in record keeping
#' @param verbose verbosity
#' @param eval_llik evaluate log-likelihood
#' @param a0 gamma(a0, b0)
#' @param b0 gamma(a0, b0)
#' @param rseed random seed
#' @param NUM_THREADS number of parallel jobs
#'
asap_fit_nmf <- function(Y, maxK, mcem = 100L, burnin = 10L, do_sample_col_row = TRUE, latent_iter = 1L, degree_iter = 1L, thining = 3L, verbose = TRUE, eval_llik = TRUE, a0 = 1., b0 = 1., rseed = 42L, NUM_THREADS = 1L) {
    .Call('_asapR_asap_fit_nmf', PACKAGE = 'asapR', Y, maxK, mcem, burnin, do_sample_col_row, latent_iter, degree_iter, thining, verbose, eval_llik, a0, b0, rseed, NUM_THREADS)
}

#' Generate approximate pseudo-bulk data by random projections
#'
#' @param mtx_file matrix-market-formatted data file (bgzip)
#' @param memory_location column indexing for the mtx
#' @param num_factors a desired number of random factors
#' @param rseed random seed
#' @param verbose verbosity
#' @param NUM_THREADS number of threads in data reading
#' @param BLOCK_SIZE disk I/O block size (number of columns)
#'
asap_random_bulk_data <- function(mtx_file, memory_location, num_factors, rseed = 42L, verbose = FALSE, NUM_THREADS = 1L, BLOCK_SIZE = 100L) {
    .Call('_asapR_asap_random_bulk_data', PACKAGE = 'asapR', mtx_file, memory_location, num_factors, rseed, verbose, NUM_THREADS, BLOCK_SIZE)
}

#' Clustering the rows of a count data matrix
#'
#' @param X data matrix
#' @param Ltrunc DPM truncation level
#' @param alpha DPM parameter
#' @param a0 prior ~ Gamma(a0, b0) (default: 1e-2)
#' @param b0 prior ~ Gamma(a0, b0) (default: 1e-4)
#' @param rseed random seed (default: 42)
#' @param mcmc number of MCMC iterations (default: 100)
#' @param burnin number iterations to discard (default: 10)
#' @param verbose verbosity
#'
fit_poisson_cluster_rows <- function(X, Ltrunc, alpha = 1, a0 = 1e-2, b0 = 1e-4, rseed = 42L, mcmc = 100L, burnin = 10L, verbose = TRUE) {
    .Call('_asapR_fit_poisson_cluster_rows', PACKAGE = 'asapR', X, Ltrunc, alpha, a0, b0, rseed, mcmc, burnin, verbose)
}

#' Create an index file for a given MTX
#'
#' @param mtx_file data file
#' @param index_file index file
#'
#' @usage mmutil_build_index(mtx_file, index_file)
#'
#' @return EXIT_SUCCESS or EXIT_FAILURE
#'
mmutil_build_index <- function(mtx_file, index_file = "") {
    .Call('_asapR_mmutil_build_index', PACKAGE = 'asapR', mtx_file, index_file)
}

#' Read an index file to R
#'
#' @param index_file index file
#'
#' @return a vector column index (a vector of memory locations)
#'
mmutil_read_index <- function(index_file) {
    .Call('_asapR_mmutil_read_index', PACKAGE = 'asapR', index_file)
}

#' Check if the index tab is valid
#'
#' @param mtx_file data file
#' @param index_tab index tab (a vector of memory locations)
#'
#' @return EXIT_SUCCESS or EXIT_FAILURE
#'
mmutil_check_index <- function(mtx_file, index_tab) {
    .Call('_asapR_mmutil_check_index', PACKAGE = 'asapR', mtx_file, index_tab)
}

#' Just read the header information
#'
#' @param mtx_file data file
#'
#' @return info
#'
mmutil_info <- function(mtx_file) {
    .Call('_asapR_mmutil_info', PACKAGE = 'asapR', mtx_file)
}

#' Write down sparse matrix to the disk
#' @param X sparse matrix
#' @param mtx_file file name
#'
#' @return EXIT_SUCCESS or EXIT_FAILURE
mmutil_write_mtx <- function(X, mtx_file) {
    .Call('_asapR_mmutil_write_mtx', PACKAGE = 'asapR', X, mtx_file)
}

#' Read a subset of columns from the data matrix
#' @param mtx_file data file
#' @param memory_location column -> memory location
#' @param r_column_index column indexes to retrieve (1-based)
#'
#' @return lists of rows, columns, values
#'
mmutil_read_columns_sparse <- function(mtx_file, memory_location, r_column_index, verbose = FALSE, NUM_THREADS = 1L, MIN_SIZE = 10L) {
    .Call('_asapR_mmutil_read_columns_sparse', PACKAGE = 'asapR', mtx_file, memory_location, r_column_index, verbose, NUM_THREADS, MIN_SIZE)
}

#' Read a subset of columns from the data matrix
#' @param mtx_file data file
#' @param memory_location column -> memory location
#' @param r_column_index column indexes to retrieve (1-based)
#'
#' @return a dense sub-matrix
#'
#' @examples
#'
#' rr <- rgamma(100, 1, 1) # one hundred cells
#' mm <- matrix(rgamma(10 * 3, 1, 1), 10, 3)
#' data.hdr <- "test_sim"
#' .files <- mmutilR::mmutil_simulate_poisson(mm, rr, data.hdr)
#' data.file <- .files$mtx
#' idx.file <- .files$idx
#' mtx.idx <- mmutilR::mmutil_read_index(idx.file)
#' Y <- as.matrix(Matrix::readMM(data.file))
#' col.pos <- c(1,13,77) # 1-based
#' yy <- mmutilR::mmutil_read_columns(
#'                  data.file, mtx.idx, col.pos)
#' all(Y[, col.pos, drop = FALSE] == yy)
#' print(head(Y[, col.pos, drop = FALSE]))
#' print(head(yy))
#' unlink(list.files(pattern = data.hdr))
#'
mmutil_read_columns <- function(mtx_file, memory_location, r_column_index, verbose = FALSE, NUM_THREADS = 1L, MIN_SIZE = 10L) {
    .Call('_asapR_mmutil_read_columns', PACKAGE = 'asapR', mtx_file, memory_location, r_column_index, verbose, NUM_THREADS, MIN_SIZE)
}

#' Simulate sparse counting data with a mixture of Poisson parameters
#'
#'
#' @param r_mu_list a list of gene x individual matrices
#' @param Ncell the total number of cells (may not make it if too sparse)
#' @param output a file header string for output files
#' @param dir_alpha a parameter for Dirichlet(alpha * [1, ..., 1])
#' @param gam_alpha a parameter for Gamma(alpha, beta)
#' @param gam_beta a parameter for Gamma(alpha, beta)
#' @param rseed random seed
#'
mmutil_simulate_poisson_mixture <- function(r_mu_list, Ncell, output, dir_alpha = 1.0, gam_alpha = 2.0, gam_beta = 2.0, rseed = 42L) {
    .Call('_asapR_mmutil_simulate_poisson_mixture', PACKAGE = 'asapR', r_mu_list, Ncell, output, dir_alpha, gam_alpha, gam_beta, rseed)
}

#' Simulation Poisson data based on Mu
#'
#' M= num. of features and n= num. of indv
#'
#' @param mu depth-adjusted mean matrix (M x n)
#' @param rho column depth vector (N x 1), N= num. of cells
#' @param output header for ${output}.{mtx.gz,cols.gz,indv.gz}
#' @param r_indv N x 1 individual membership (1-based, [1 .. n])
#' @param rseed random seed
#'
#' @return a list of file names: {output}.{mtx,rows,cols}.gz
#'
mmutil_simulate_poisson <- function(mu, rho, output, r_indv = NULL, rseed = 42L) {
    .Call('_asapR_mmutil_simulate_poisson', PACKAGE = 'asapR', mu, rho, output, r_indv, rseed)
}

